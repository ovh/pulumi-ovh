# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertingFormattedMonthlyThresholdArgs',
    'AlertingFormattedMonthlyThresholdArgsDict',
    'ContainerRegistryPlanArgs',
    'ContainerRegistryPlanArgsDict',
    'ContainerRegistryPlanFeatureArgs',
    'ContainerRegistryPlanFeatureArgsDict',
    'ContainerRegistryPlanRegistryLimitArgs',
    'ContainerRegistryPlanRegistryLimitArgsDict',
    'DatabaseEndpointArgs',
    'DatabaseEndpointArgsDict',
    'DatabaseIpRestrictionArgs',
    'DatabaseIpRestrictionArgsDict',
    'DatabaseNodeArgs',
    'DatabaseNodeArgsDict',
    'GatewayExternalInformationArgs',
    'GatewayExternalInformationArgsDict',
    'GatewayExternalInformationIpArgs',
    'GatewayExternalInformationIpArgsDict',
    'GatewayInterfaceArgs',
    'GatewayInterfaceArgsDict',
    'InstanceAddressArgs',
    'InstanceAddressArgsDict',
    'InstanceAttachedVolumeArgs',
    'InstanceAttachedVolumeArgsDict',
    'InstanceAutoBackupArgs',
    'InstanceAutoBackupArgsDict',
    'InstanceBootFromArgs',
    'InstanceBootFromArgsDict',
    'InstanceFlavorArgs',
    'InstanceFlavorArgsDict',
    'InstanceGroupArgs',
    'InstanceGroupArgsDict',
    'InstanceNetworkArgs',
    'InstanceNetworkArgsDict',
    'InstanceNetworkPrivateArgs',
    'InstanceNetworkPrivateArgsDict',
    'InstanceNetworkPrivateFloatingIpArgs',
    'InstanceNetworkPrivateFloatingIpArgsDict',
    'InstanceNetworkPrivateFloatingIpCreateArgs',
    'InstanceNetworkPrivateFloatingIpCreateArgsDict',
    'InstanceNetworkPrivateGatewayArgs',
    'InstanceNetworkPrivateGatewayArgsDict',
    'InstanceNetworkPrivateGatewayCreateArgs',
    'InstanceNetworkPrivateGatewayCreateArgsDict',
    'InstanceNetworkPrivateNetworkArgs',
    'InstanceNetworkPrivateNetworkArgsDict',
    'InstanceNetworkPrivateNetworkCreateArgs',
    'InstanceNetworkPrivateNetworkCreateArgsDict',
    'InstanceNetworkPrivateNetworkCreateSubnetArgs',
    'InstanceNetworkPrivateNetworkCreateSubnetArgsDict',
    'InstanceSshKeyArgs',
    'InstanceSshKeyArgsDict',
    'InstanceSshKeyCreateArgs',
    'InstanceSshKeyCreateArgsDict',
    'KubeCustomizationArgs',
    'KubeCustomizationArgsDict',
    'KubeCustomizationApiserverArgs',
    'KubeCustomizationApiserverArgsDict',
    'KubeCustomizationApiserverAdmissionpluginArgs',
    'KubeCustomizationApiserverAdmissionpluginArgsDict',
    'KubeCustomizationKubeProxyArgs',
    'KubeCustomizationKubeProxyArgsDict',
    'KubeCustomizationKubeProxyIptablesArgs',
    'KubeCustomizationKubeProxyIptablesArgsDict',
    'KubeCustomizationKubeProxyIpvsArgs',
    'KubeCustomizationKubeProxyIpvsArgsDict',
    'KubeKubeconfigAttributeArgs',
    'KubeKubeconfigAttributeArgsDict',
    'KubeNodePoolTemplateArgs',
    'KubeNodePoolTemplateArgsDict',
    'KubeNodePoolTemplateMetadataArgs',
    'KubeNodePoolTemplateMetadataArgsDict',
    'KubeNodePoolTemplateSpecArgs',
    'KubeNodePoolTemplateSpecArgsDict',
    'KubePrivateNetworkConfigurationArgs',
    'KubePrivateNetworkConfigurationArgsDict',
    'LoadBalancerFloatingIpArgs',
    'LoadBalancerFloatingIpArgsDict',
    'LoadBalancerListenerArgs',
    'LoadBalancerListenerArgsDict',
    'LoadBalancerListenerPoolArgs',
    'LoadBalancerListenerPoolArgsDict',
    'LoadBalancerListenerPoolHealthMonitorArgs',
    'LoadBalancerListenerPoolHealthMonitorArgsDict',
    'LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs',
    'LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgsDict',
    'LoadBalancerListenerPoolMemberArgs',
    'LoadBalancerListenerPoolMemberArgsDict',
    'LoadBalancerListenerPoolSessionPersistenceArgs',
    'LoadBalancerListenerPoolSessionPersistenceArgsDict',
    'LoadBalancerNetworkArgs',
    'LoadBalancerNetworkArgsDict',
    'LoadBalancerNetworkPrivateArgs',
    'LoadBalancerNetworkPrivateArgsDict',
    'LoadBalancerNetworkPrivateFloatingIpArgs',
    'LoadBalancerNetworkPrivateFloatingIpArgsDict',
    'LoadBalancerNetworkPrivateFloatingIpCreateArgs',
    'LoadBalancerNetworkPrivateFloatingIpCreateArgsDict',
    'LoadBalancerNetworkPrivateGatewayArgs',
    'LoadBalancerNetworkPrivateGatewayArgsDict',
    'LoadBalancerNetworkPrivateGatewayCreateArgs',
    'LoadBalancerNetworkPrivateGatewayCreateArgsDict',
    'LoadBalancerNetworkPrivateNetworkArgs',
    'LoadBalancerNetworkPrivateNetworkArgsDict',
    'NetworkPrivateRegionsAttributeArgs',
    'NetworkPrivateRegionsAttributeArgsDict',
    'NetworkPrivateRegionsStatusArgs',
    'NetworkPrivateRegionsStatusArgsDict',
    'NetworkPrivateSubnetIpPoolArgs',
    'NetworkPrivateSubnetIpPoolArgsDict',
    'NetworkPrivateSubnetV2AllocationPoolArgs',
    'NetworkPrivateSubnetV2AllocationPoolArgsDict',
    'NetworkPrivateSubnetV2HostRouteArgs',
    'NetworkPrivateSubnetV2HostRouteArgsDict',
    'ProjectOrderArgs',
    'ProjectOrderArgsDict',
    'ProjectOrderDetailArgs',
    'ProjectOrderDetailArgsDict',
    'ProjectPlanArgs',
    'ProjectPlanArgsDict',
    'ProjectPlanConfigurationArgs',
    'ProjectPlanConfigurationArgsDict',
    'ProjectPlanOptionArgs',
    'ProjectPlanOptionArgsDict',
    'ProjectPlanOptionConfigurationArgs',
    'ProjectPlanOptionConfigurationArgsDict',
    'ProjectRegionServiceArgs',
    'ProjectRegionServiceArgsDict',
    'RancherCurrentStateArgs',
    'RancherCurrentStateArgsDict',
    'RancherCurrentStateIpRestrictionArgs',
    'RancherCurrentStateIpRestrictionArgsDict',
    'RancherCurrentStateNetworkingArgs',
    'RancherCurrentStateNetworkingArgsDict',
    'RancherCurrentStateUsageArgs',
    'RancherCurrentStateUsageArgsDict',
    'RancherCurrentTaskArgs',
    'RancherCurrentTaskArgsDict',
    'RancherTargetSpecArgs',
    'RancherTargetSpecArgsDict',
    'RancherTargetSpecIpRestrictionArgs',
    'RancherTargetSpecIpRestrictionArgsDict',
    'RegionNetworkSubnetArgs',
    'RegionNetworkSubnetArgsDict',
    'RegionNetworkSubnetAllocationPoolArgs',
    'RegionNetworkSubnetAllocationPoolArgsDict',
    'RegionNetworkSubnetHostRouteArgs',
    'RegionNetworkSubnetHostRouteArgsDict',
    'StorageEncryptionArgs',
    'StorageEncryptionArgsDict',
    'StorageObjectArgs',
    'StorageObjectArgsDict',
    'StorageReplicationArgs',
    'StorageReplicationArgsDict',
    'StorageReplicationRuleArgs',
    'StorageReplicationRuleArgsDict',
    'StorageReplicationRuleDestinationArgs',
    'StorageReplicationRuleDestinationArgsDict',
    'StorageReplicationRuleFilterArgs',
    'StorageReplicationRuleFilterArgsDict',
    'StorageVersioningArgs',
    'StorageVersioningArgsDict',
    'UserRoleArgs',
    'UserRoleArgsDict',
    'VolumeSubOperationArgs',
    'VolumeSubOperationArgsDict',
    'GetKubeCustomizationArgs',
    'GetKubeCustomizationArgsDict',
    'GetKubeCustomizationApiserverArgs',
    'GetKubeCustomizationApiserverArgsDict',
    'GetKubeCustomizationApiserverAdmissionpluginArgs',
    'GetKubeCustomizationApiserverAdmissionpluginArgsDict',
    'GetKubeCustomizationKubeProxyArgs',
    'GetKubeCustomizationKubeProxyArgsDict',
    'GetKubeCustomizationKubeProxyIptablesArgs',
    'GetKubeCustomizationKubeProxyIptablesArgsDict',
    'GetKubeCustomizationKubeProxyIpvsArgs',
    'GetKubeCustomizationKubeProxyIpvsArgsDict',
    'GetKubeNodePoolTemplateArgs',
    'GetKubeNodePoolTemplateArgsDict',
    'GetKubeNodePoolTemplateMetadataArgs',
    'GetKubeNodePoolTemplateMetadataArgsDict',
    'GetKubeNodePoolTemplateSpecArgs',
    'GetKubeNodePoolTemplateSpecArgsDict',
]

MYPY = False

if not MYPY:
    class AlertingFormattedMonthlyThresholdArgsDict(TypedDict):
        currency_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Currency of the monthly threshold
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text representation of the monthly threshold
        """
        value: NotRequired[pulumi.Input[_builtins.float]]
        """
        Value of the monthly threshold
        """
elif False:
    AlertingFormattedMonthlyThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertingFormattedMonthlyThresholdArgs:
    def __init__(__self__, *,
                 currency_code: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] currency_code: Currency of the monthly threshold
        :param pulumi.Input[_builtins.str] text: Text representation of the monthly threshold
        :param pulumi.Input[_builtins.float] value: Value of the monthly threshold
        """
        if currency_code is not None:
            pulumi.set(__self__, "currency_code", currency_code)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Currency of the monthly threshold
        """
        return pulumi.get(self, "currency_code")

    @currency_code.setter
    def currency_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency_code", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text representation of the monthly threshold
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Value of the monthly threshold
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerRegistryPlanArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plan code from the catalog
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plan creation date
        """
        features: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanFeatureArgsDict']]]]
        """
        Features of the plan
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plan ID
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Registry name
        """
        registry_limits: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanRegistryLimitArgsDict']]]]
        """
        Container registry limits
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Registry last update date
        """
elif False:
    ContainerRegistryPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRegistryPlanArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 features: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanFeatureArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_limits: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanRegistryLimitArgs']]]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: Plan code from the catalog
        :param pulumi.Input[_builtins.str] created_at: Plan creation date
        :param pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanFeatureArgs']]] features: Features of the plan
        :param pulumi.Input[_builtins.str] id: Plan ID
        :param pulumi.Input[_builtins.str] name: Registry name
        :param pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanRegistryLimitArgs']]] registry_limits: Container registry limits
        :param pulumi.Input[_builtins.str] updated_at: Registry last update date
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if registry_limits is not None:
            pulumi.set(__self__, "registry_limits", registry_limits)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plan code from the catalog
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plan creation date
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanFeatureArgs']]]]:
        """
        Features of the plan
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanFeatureArgs']]]]):
        pulumi.set(self, "features", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plan ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Registry name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="registryLimits")
    def registry_limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanRegistryLimitArgs']]]]:
        """
        Container registry limits
        """
        return pulumi.get(self, "registry_limits")

    @registry_limits.setter
    def registry_limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRegistryPlanRegistryLimitArgs']]]]):
        pulumi.set(self, "registry_limits", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Registry last update date
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ContainerRegistryPlanFeatureArgsDict(TypedDict):
        vulnerability: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Vulnerability scanning
        """
elif False:
    ContainerRegistryPlanFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRegistryPlanFeatureArgs:
    def __init__(__self__, *,
                 vulnerability: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] vulnerability: Vulnerability scanning
        """
        if vulnerability is not None:
            pulumi.set(__self__, "vulnerability", vulnerability)

    @_builtins.property
    @pulumi.getter
    def vulnerability(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Vulnerability scanning
        """
        return pulumi.get(self, "vulnerability")

    @vulnerability.setter
    def vulnerability(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "vulnerability", value)


if not MYPY:
    class ContainerRegistryPlanRegistryLimitArgsDict(TypedDict):
        image_storage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Docker image storage limits in bytes
        """
        parallel_request: NotRequired[pulumi.Input[_builtins.int]]
        """
        Parallel requests on Docker image API (/v2 Docker registry API)
        """
elif False:
    ContainerRegistryPlanRegistryLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRegistryPlanRegistryLimitArgs:
    def __init__(__self__, *,
                 image_storage: Optional[pulumi.Input[_builtins.int]] = None,
                 parallel_request: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] image_storage: Docker image storage limits in bytes
        :param pulumi.Input[_builtins.int] parallel_request: Parallel requests on Docker image API (/v2 Docker registry API)
        """
        if image_storage is not None:
            pulumi.set(__self__, "image_storage", image_storage)
        if parallel_request is not None:
            pulumi.set(__self__, "parallel_request", parallel_request)

    @_builtins.property
    @pulumi.getter(name="imageStorage")
    def image_storage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Docker image storage limits in bytes
        """
        return pulumi.get(self, "image_storage")

    @image_storage.setter
    def image_storage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "image_storage", value)

    @_builtins.property
    @pulumi.getter(name="parallelRequest")
    def parallel_request(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Parallel requests on Docker image API (/v2 Docker registry API)
        """
        return pulumi.get(self, "parallel_request")

    @parallel_request.setter
    def parallel_request(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "parallel_request", value)


if not MYPY:
    class DatabaseEndpointArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of component the URI relates to.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain of the cluster.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connection port for the endpoint.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheme used to generate the URI.
        """
        ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the endpoint uses SSL.
        """
        ssl_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSL mode used to connect to the service if the SSL is enabled.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the endpoint.
        """
elif False:
    DatabaseEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseEndpointArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssl_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] component: Type of component the URI relates to.
        :param pulumi.Input[_builtins.str] domain: Domain of the cluster.
        :param pulumi.Input[_builtins.str] path: Path of the endpoint.
        :param pulumi.Input[_builtins.int] port: Connection port for the endpoint.
        :param pulumi.Input[_builtins.str] scheme: Scheme used to generate the URI.
        :param pulumi.Input[_builtins.bool] ssl: Defines whether the endpoint uses SSL.
        :param pulumi.Input[_builtins.str] ssl_mode: SSL mode used to connect to the service if the SSL is enabled.
        :param pulumi.Input[_builtins.str] uri: URI of the endpoint.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of component the URI relates to.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain of the cluster.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path of the endpoint.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connection port for the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheme used to generate the URI.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the endpoint uses SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ssl", value)

    @_builtins.property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSL mode used to connect to the service if the SSL is enabled.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_mode", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the endpoint.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DatabaseIpRestrictionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the IP restriction
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorized IP
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current status of the cluster.
        """
elif False:
    DatabaseIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseIpRestrictionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the IP restriction
        :param pulumi.Input[_builtins.str] ip: Authorized IP
        :param pulumi.Input[_builtins.str] status: Current status of the cluster.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the IP restriction
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorized IP
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current status of the cluster.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DatabaseNodeArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Public cloud region in which the node should be deployed. Ex: "GRA'.
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private network id in which the node should be deployed. It's the regional openstackId of the private network
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private subnet ID in which the node is.
        """
elif False:
    DatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseNodeArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Public cloud region in which the node should be deployed. Ex: "GRA'.
        :param pulumi.Input[_builtins.str] network_id: Private network id in which the node should be deployed. It's the regional openstackId of the private network
        :param pulumi.Input[_builtins.str] subnet_id: Private subnet ID in which the node is.
        """
        pulumi.set(__self__, "region", region)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Public cloud region in which the node should be deployed. Ex: "GRA'.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private network id in which the node should be deployed. It's the regional openstackId of the private network
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private subnet ID in which the node is.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class GatewayExternalInformationArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayExternalInformationIpArgsDict']]]]
        """
        List of external ips of the gateway.
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the private network.
        """
elif False:
    GatewayExternalInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayExternalInformationArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayExternalInformationIpArgs']]]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewayExternalInformationIpArgs']]] ips: List of external ips of the gateway.
        :param pulumi.Input[_builtins.str] network_id: ID of the private network.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayExternalInformationIpArgs']]]]:
        """
        List of external ips of the gateway.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayExternalInformationIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the private network.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class GatewayExternalInformationIpArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP of the interface.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the subnet.
        """
elif False:
    GatewayExternalInformationIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayExternalInformationIpArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IP of the interface.
        :param pulumi.Input[_builtins.str] subnet_id: ID of the subnet.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP of the interface.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class GatewayInterfaceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the interface.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP of the interface.
        """
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the private network.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the subnet.
        """
elif False:
    GatewayInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayInterfaceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the interface.
        :param pulumi.Input[_builtins.str] ip: IP of the interface.
        :param pulumi.Input[_builtins.str] network_id: ID of the private network.
        :param pulumi.Input[_builtins.str] subnet_id: ID of the subnet.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the interface.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP of the interface.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the private network.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class InstanceAddressArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        IP version
        """
elif False:
    InstanceAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAddressArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IP address
        :param pulumi.Input[_builtins.int] version: IP version
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        IP version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class InstanceAttachedVolumeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance id
        """
elif False:
    InstanceAttachedVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAttachedVolumeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Instance id
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InstanceAutoBackupArgsDict(TypedDict):
        cron: pulumi.Input[_builtins.str]
        """
        Unix cron pattern
        """
        rotation: pulumi.Input[_builtins.int]
        """
        Number of backup to keep
        """
elif False:
    InstanceAutoBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAutoBackupArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[_builtins.str],
                 rotation: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] cron: Unix cron pattern
        :param pulumi.Input[_builtins.int] rotation: Number of backup to keep
        """
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "rotation", rotation)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        """
        Unix cron pattern
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter
    def rotation(self) -> pulumi.Input[_builtins.int]:
        """
        Number of backup to keep
        """
        return pulumi.get(self, "rotation")

    @rotation.setter
    def rotation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rotation", value)


if not MYPY:
    class InstanceBootFromArgsDict(TypedDict):
        image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance image id. Images can be retrieved using `GET /cloud/project/{serviceName}/image`
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance volume id
        """
elif False:
    InstanceBootFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBootFromArgs:
    def __init__(__self__, *,
                 image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image_id: Instance image id. Images can be retrieved using `GET /cloud/project/{serviceName}/image`
        :param pulumi.Input[_builtins.str] volume_id: Instance volume id
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance image id. Images can be retrieved using `GET /cloud/project/{serviceName}/image`
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance volume id
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class InstanceFlavorArgsDict(TypedDict):
        flavor_id: pulumi.Input[_builtins.str]
        """
        Flavor ID. Flavors can be retrieved using `GET /cloud/project/{serviceName}/flavor`
        """
elif False:
    InstanceFlavorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceFlavorArgs:
    def __init__(__self__, *,
                 flavor_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] flavor_id: Flavor ID. Flavors can be retrieved using `GET /cloud/project/{serviceName}/flavor`
        """
        pulumi.set(__self__, "flavor_id", flavor_id)

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> pulumi.Input[_builtins.str]:
        """
        Flavor ID. Flavors can be retrieved using `GET /cloud/project/{serviceName}/flavor`
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor_id", value)


if not MYPY:
    class InstanceGroupArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group id
        """
elif False:
    InstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceGroupArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] group_id: Group id
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group id
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)


if not MYPY:
    class InstanceNetworkArgsDict(TypedDict):
        private: NotRequired[pulumi.Input['InstanceNetworkPrivateArgsDict']]
        """
        Private network information
        """
        public: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set the new instance as public
        """
elif False:
    InstanceNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input['InstanceNetworkPrivateArgs']] = None,
                 public: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['InstanceNetworkPrivateArgs'] private: Private network information
        :param pulumi.Input[_builtins.bool] public: Set the new instance as public
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input['InstanceNetworkPrivateArgs']]:
        """
        Private network information
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input['InstanceNetworkPrivateArgs']]):
        pulumi.set(self, "private", value)

    @_builtins.property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set the new instance as public
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public", value)


if not MYPY:
    class InstanceNetworkPrivateArgsDict(TypedDict):
        floating_ip: NotRequired[pulumi.Input['InstanceNetworkPrivateFloatingIpArgsDict']]
        """
        Existing floating IP
        """
        floating_ip_create: NotRequired[pulumi.Input['InstanceNetworkPrivateFloatingIpCreateArgsDict']]
        """
        Information to create a new floating IP
        """
        gateway: NotRequired[pulumi.Input['InstanceNetworkPrivateGatewayArgsDict']]
        """
        Existing gateway
        """
        gateway_create: NotRequired[pulumi.Input['InstanceNetworkPrivateGatewayCreateArgsDict']]
        """
        Information to create a new gateway
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance IP in the private network
        """
        network: NotRequired[pulumi.Input['InstanceNetworkPrivateNetworkArgsDict']]
        """
        Existing private network
        """
        network_create: NotRequired[pulumi.Input['InstanceNetworkPrivateNetworkCreateArgsDict']]
        """
        Information to create a new private network
        """
elif False:
    InstanceNetworkPrivateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateArgs:
    def __init__(__self__, *,
                 floating_ip: Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpArgs']] = None,
                 floating_ip_create: Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpCreateArgs']] = None,
                 gateway: Optional[pulumi.Input['InstanceNetworkPrivateGatewayArgs']] = None,
                 gateway_create: Optional[pulumi.Input['InstanceNetworkPrivateGatewayCreateArgs']] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input['InstanceNetworkPrivateNetworkArgs']] = None,
                 network_create: Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateArgs']] = None):
        """
        :param pulumi.Input['InstanceNetworkPrivateFloatingIpArgs'] floating_ip: Existing floating IP
        :param pulumi.Input['InstanceNetworkPrivateFloatingIpCreateArgs'] floating_ip_create: Information to create a new floating IP
        :param pulumi.Input['InstanceNetworkPrivateGatewayArgs'] gateway: Existing gateway
        :param pulumi.Input['InstanceNetworkPrivateGatewayCreateArgs'] gateway_create: Information to create a new gateway
        :param pulumi.Input[_builtins.str] ip: Instance IP in the private network
        :param pulumi.Input['InstanceNetworkPrivateNetworkArgs'] network: Existing private network
        :param pulumi.Input['InstanceNetworkPrivateNetworkCreateArgs'] network_create: Information to create a new private network
        """
        if floating_ip is not None:
            pulumi.set(__self__, "floating_ip", floating_ip)
        if floating_ip_create is not None:
            pulumi.set(__self__, "floating_ip_create", floating_ip_create)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway_create is not None:
            pulumi.set(__self__, "gateway_create", gateway_create)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_create is not None:
            pulumi.set(__self__, "network_create", network_create)

    @_builtins.property
    @pulumi.getter(name="floatingIp")
    def floating_ip(self) -> Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpArgs']]:
        """
        Existing floating IP
        """
        return pulumi.get(self, "floating_ip")

    @floating_ip.setter
    def floating_ip(self, value: Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpArgs']]):
        pulumi.set(self, "floating_ip", value)

    @_builtins.property
    @pulumi.getter(name="floatingIpCreate")
    def floating_ip_create(self) -> Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpCreateArgs']]:
        """
        Information to create a new floating IP
        """
        return pulumi.get(self, "floating_ip_create")

    @floating_ip_create.setter
    def floating_ip_create(self, value: Optional[pulumi.Input['InstanceNetworkPrivateFloatingIpCreateArgs']]):
        pulumi.set(self, "floating_ip_create", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input['InstanceNetworkPrivateGatewayArgs']]:
        """
        Existing gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input['InstanceNetworkPrivateGatewayArgs']]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter(name="gatewayCreate")
    def gateway_create(self) -> Optional[pulumi.Input['InstanceNetworkPrivateGatewayCreateArgs']]:
        """
        Information to create a new gateway
        """
        return pulumi.get(self, "gateway_create")

    @gateway_create.setter
    def gateway_create(self, value: Optional[pulumi.Input['InstanceNetworkPrivateGatewayCreateArgs']]):
        pulumi.set(self, "gateway_create", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance IP in the private network
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['InstanceNetworkPrivateNetworkArgs']]:
        """
        Existing private network
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['InstanceNetworkPrivateNetworkArgs']]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="networkCreate")
    def network_create(self) -> Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateArgs']]:
        """
        Information to create a new private network
        """
        return pulumi.get(self, "network_create")

    @network_create.setter
    def network_create(self, value: Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateArgs']]):
        pulumi.set(self, "network_create", value)


if not MYPY:
    class InstanceNetworkPrivateFloatingIpArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Floating IP ID
        """
elif False:
    InstanceNetworkPrivateFloatingIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateFloatingIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Floating IP ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Floating IP ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InstanceNetworkPrivateFloatingIpCreateArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Floating IP description
        """
elif False:
    InstanceNetworkPrivateFloatingIpCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateFloatingIpCreateArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Floating IP description
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Floating IP description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class InstanceNetworkPrivateGatewayArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway ID
        """
elif False:
    InstanceNetworkPrivateGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateGatewayArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Gateway ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InstanceNetworkPrivateGatewayCreateArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway model (s | m | l)
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway name
        """
elif False:
    InstanceNetworkPrivateGatewayCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateGatewayCreateArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: Gateway model (s | m | l)
        :param pulumi.Input[_builtins.str] name: Gateway name
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway model (s | m | l)
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InstanceNetworkPrivateNetworkArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network ID
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Existing subnet ID
        * network_create - (Optional, Forces new resource) Information to create a new private network
        """
elif False:
    InstanceNetworkPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Network ID
        :param pulumi.Input[_builtins.str] subnet_id: Existing subnet ID
               * network_create - (Optional, Forces new resource) Information to create a new private network
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Existing subnet ID
        * network_create - (Optional, Forces new resource) Information to create a new private network
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class InstanceNetworkPrivateNetworkCreateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance name
        """
        subnet: NotRequired[pulumi.Input['InstanceNetworkPrivateNetworkCreateSubnetArgsDict']]
        """
        New subnet information
        """
        vlan_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Network vlan ID
        """
elif False:
    InstanceNetworkPrivateNetworkCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateNetworkCreateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateSubnetArgs']] = None,
                 vlan_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Instance name
        :param pulumi.Input['InstanceNetworkPrivateNetworkCreateSubnetArgs'] subnet: New subnet information
        :param pulumi.Input[_builtins.int] vlan_id: Network vlan ID
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateSubnetArgs']]:
        """
        New subnet information
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['InstanceNetworkPrivateNetworkCreateSubnetArgs']]):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Network vlan ID
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class InstanceNetworkPrivateNetworkCreateSubnetArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet range in CIDR notation
        """
        enable_dhcp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable DHCP
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        IP version
        """
elif False:
    InstanceNetworkPrivateNetworkCreateSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkPrivateNetworkCreateSubnetArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_dhcp: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: Subnet range in CIDR notation
        :param pulumi.Input[_builtins.bool] enable_dhcp: Whether to enable DHCP
        :param pulumi.Input[_builtins.int] ip_version: IP version
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if enable_dhcp is not None:
            pulumi.set(__self__, "enable_dhcp", enable_dhcp)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet range in CIDR notation
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter(name="enableDhcp")
    def enable_dhcp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable DHCP
        """
        return pulumi.get(self, "enable_dhcp")

    @enable_dhcp.setter
    def enable_dhcp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_dhcp", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        IP version
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class InstanceSshKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        SSH Keypair name
        """
elif False:
    InstanceSshKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSshKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: SSH Keypair name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        SSH Keypair name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InstanceSshKeyCreateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        SSH Key pair name
        """
        public_key: pulumi.Input[_builtins.str]
        """
        SSH Public key
        """
elif False:
    InstanceSshKeyCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSshKeyCreateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 public_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: SSH Key pair name
        :param pulumi.Input[_builtins.str] public_key: SSH Public key
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_key", public_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        SSH Key pair name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[_builtins.str]:
        """
        SSH Public key
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class KubeCustomizationArgsDict(TypedDict):
        apiservers: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverArgsDict']]]]
        """
        Kubernetes API server customization
        """
elif False:
    KubeCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationArgs:
    def __init__(__self__, *,
                 apiservers: Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverArgs']]] apiservers: Kubernetes API server customization
        """
        if apiservers is not None:
            warnings.warn("""Use customization_apiserver instead""", DeprecationWarning)
            pulumi.log.warn("""apiservers is deprecated: Use customization_apiserver instead""")
        if apiservers is not None:
            pulumi.set(__self__, "apiservers", apiservers)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use customization_apiserver instead""")
    def apiservers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverArgs']]]]:
        """
        Kubernetes API server customization
        """
        return pulumi.get(self, "apiservers")

    @apiservers.setter
    def apiservers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverArgs']]]]):
        pulumi.set(self, "apiservers", value)


if not MYPY:
    class KubeCustomizationApiserverArgsDict(TypedDict):
        admissionplugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverAdmissionpluginArgsDict']]]]
        """
        Kubernetes API server admission plugins customization
        """
elif False:
    KubeCustomizationApiserverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationApiserverArgs:
    def __init__(__self__, *,
                 admissionplugins: Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverAdmissionpluginArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverAdmissionpluginArgs']]] admissionplugins: Kubernetes API server admission plugins customization
        """
        if admissionplugins is not None:
            pulumi.set(__self__, "admissionplugins", admissionplugins)

    @_builtins.property
    @pulumi.getter
    def admissionplugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverAdmissionpluginArgs']]]]:
        """
        Kubernetes API server admission plugins customization
        """
        return pulumi.get(self, "admissionplugins")

    @admissionplugins.setter
    def admissionplugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubeCustomizationApiserverAdmissionpluginArgs']]]]):
        pulumi.set(self, "admissionplugins", value)


if not MYPY:
    class KubeCustomizationApiserverAdmissionpluginArgsDict(TypedDict):
        disableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        """
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
elif False:
    KubeCustomizationApiserverAdmissionpluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationApiserverAdmissionpluginArgs:
    def __init__(__self__, *,
                 disableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] disableds: Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
        if disableds is not None:
            pulumi.set(__self__, "disableds", disableds)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def disableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        """
        return pulumi.get(self, "disableds")

    @disableds.setter
    def disableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "disableds", value)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class KubeCustomizationKubeProxyArgsDict(TypedDict):
        iptables: NotRequired[pulumi.Input['KubeCustomizationKubeProxyIptablesArgsDict']]
        """
        Kubernetes cluster kube-proxy customization of iptables specific config (durations format is RFC3339 duration, e.g. `PT60S`)
        """
        ipvs: NotRequired[pulumi.Input['KubeCustomizationKubeProxyIpvsArgsDict']]
        """
        Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration, e.g. `PT60S`)
        """
elif False:
    KubeCustomizationKubeProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationKubeProxyArgs:
    def __init__(__self__, *,
                 iptables: Optional[pulumi.Input['KubeCustomizationKubeProxyIptablesArgs']] = None,
                 ipvs: Optional[pulumi.Input['KubeCustomizationKubeProxyIpvsArgs']] = None):
        """
        :param pulumi.Input['KubeCustomizationKubeProxyIptablesArgs'] iptables: Kubernetes cluster kube-proxy customization of iptables specific config (durations format is RFC3339 duration, e.g. `PT60S`)
        :param pulumi.Input['KubeCustomizationKubeProxyIpvsArgs'] ipvs: Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration, e.g. `PT60S`)
        """
        if iptables is not None:
            pulumi.set(__self__, "iptables", iptables)
        if ipvs is not None:
            pulumi.set(__self__, "ipvs", ipvs)

    @_builtins.property
    @pulumi.getter
    def iptables(self) -> Optional[pulumi.Input['KubeCustomizationKubeProxyIptablesArgs']]:
        """
        Kubernetes cluster kube-proxy customization of iptables specific config (durations format is RFC3339 duration, e.g. `PT60S`)
        """
        return pulumi.get(self, "iptables")

    @iptables.setter
    def iptables(self, value: Optional[pulumi.Input['KubeCustomizationKubeProxyIptablesArgs']]):
        pulumi.set(self, "iptables", value)

    @_builtins.property
    @pulumi.getter
    def ipvs(self) -> Optional[pulumi.Input['KubeCustomizationKubeProxyIpvsArgs']]:
        """
        Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration, e.g. `PT60S`)
        """
        return pulumi.get(self, "ipvs")

    @ipvs.setter
    def ipvs(self, value: Optional[pulumi.Input['KubeCustomizationKubeProxyIpvsArgs']]):
        pulumi.set(self, "ipvs", value)


if not MYPY:
    class KubeCustomizationKubeProxyIptablesArgsDict(TypedDict):
        min_sync_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`). Must be greater than 0.
        """
        sync_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        """
elif False:
    KubeCustomizationKubeProxyIptablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationKubeProxyIptablesArgs:
    def __init__(__self__, *,
                 min_sync_period: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_period: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] min_sync_period: Period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`). Must be greater than 0.
        :param pulumi.Input[_builtins.str] sync_period: Minimum period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        """
        if min_sync_period is not None:
            pulumi.set(__self__, "min_sync_period", min_sync_period)
        if sync_period is not None:
            pulumi.set(__self__, "sync_period", sync_period)

    @_builtins.property
    @pulumi.getter(name="minSyncPeriod")
    def min_sync_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`). Must be greater than 0.
        """
        return pulumi.get(self, "min_sync_period")

    @min_sync_period.setter
    def min_sync_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_sync_period", value)

    @_builtins.property
    @pulumi.getter(name="syncPeriod")
    def sync_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum period that iptables rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        """
        return pulumi.get(self, "sync_period")

    @sync_period.setter
    def sync_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sync_period", value)


if not MYPY:
    class KubeCustomizationKubeProxyIpvsArgsDict(TypedDict):
        min_sync_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`).
        """
        scheduler: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPVS scheduler.
        """
        sync_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        """
        tcp_fin_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        tcp_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        udp_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
elif False:
    KubeCustomizationKubeProxyIpvsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeCustomizationKubeProxyIpvsArgs:
    def __init__(__self__, *,
                 min_sync_period: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduler: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_period: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_fin_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 udp_timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] min_sync_period: Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`).
        :param pulumi.Input[_builtins.str] scheduler: IPVS scheduler.
        :param pulumi.Input[_builtins.str] sync_period: Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        :param pulumi.Input[_builtins.str] tcp_fin_timeout: Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        :param pulumi.Input[_builtins.str] tcp_timeout: Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        :param pulumi.Input[_builtins.str] udp_timeout: timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        if min_sync_period is not None:
            pulumi.set(__self__, "min_sync_period", min_sync_period)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)
        if sync_period is not None:
            pulumi.set(__self__, "sync_period", sync_period)
        if tcp_fin_timeout is not None:
            pulumi.set(__self__, "tcp_fin_timeout", tcp_fin_timeout)
        if tcp_timeout is not None:
            pulumi.set(__self__, "tcp_timeout", tcp_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="minSyncPeriod")
    def min_sync_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`).
        """
        return pulumi.get(self, "min_sync_period")

    @min_sync_period.setter
    def min_sync_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_sync_period", value)

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPVS scheduler.
        """
        return pulumi.get(self, "scheduler")

    @scheduler.setter
    def scheduler(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduler", value)

    @_builtins.property
    @pulumi.getter(name="syncPeriod")
    def sync_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format (e.g. `PT60S`).
        """
        return pulumi.get(self, "sync_period")

    @sync_period.setter
    def sync_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sync_period", value)

    @_builtins.property
    @pulumi.getter(name="tcpFinTimeout")
    def tcp_fin_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        return pulumi.get(self, "tcp_fin_timeout")

    @tcp_fin_timeout.setter
    def tcp_fin_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tcp_fin_timeout", value)

    @_builtins.property
    @pulumi.getter(name="tcpTimeout")
    def tcp_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        return pulumi.get(self, "tcp_timeout")

    @tcp_timeout.setter
    def tcp_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tcp_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration (e.g. `PT60S`). The default value is `PT0S`, which preserves the current timeout value on the system.
        """
        return pulumi.get(self, "udp_timeout")

    @udp_timeout.setter
    def udp_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "udp_timeout", value)


if not MYPY:
    class KubeKubeconfigAttributeArgsDict(TypedDict):
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes API server client certificate.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes API server client key.
        """
        cluster_ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes API server CA certificate.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes API server URL.
        """
elif False:
    KubeKubeconfigAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeKubeconfigAttributeArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_certificate: The kubernetes API server client certificate.
        :param pulumi.Input[_builtins.str] client_key: The kubernetes API server client key.
        :param pulumi.Input[_builtins.str] cluster_ca_certificate: The kubernetes API server CA certificate.
        :param pulumi.Input[_builtins.str] host: The kubernetes API server URL.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes API server client certificate.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes API server client key.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes API server CA certificate.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes API server URL.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class KubeNodePoolTemplateArgsDict(TypedDict):
        metadata: pulumi.Input['KubeNodePoolTemplateMetadataArgsDict']
        """
        metadata
        """
        spec: pulumi.Input['KubeNodePoolTemplateSpecArgsDict']
        """
        spec
        """
elif False:
    KubeNodePoolTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeNodePoolTemplateArgs:
    def __init__(__self__, *,
                 metadata: pulumi.Input['KubeNodePoolTemplateMetadataArgs'],
                 spec: pulumi.Input['KubeNodePoolTemplateSpecArgs']):
        """
        :param pulumi.Input['KubeNodePoolTemplateMetadataArgs'] metadata: metadata
        :param pulumi.Input['KubeNodePoolTemplateSpecArgs'] spec: spec
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> pulumi.Input['KubeNodePoolTemplateMetadataArgs']:
        """
        metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input['KubeNodePoolTemplateMetadataArgs']):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> pulumi.Input['KubeNodePoolTemplateSpecArgs']:
        """
        spec
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input['KubeNodePoolTemplateSpecArgs']):
        pulumi.set(self, "spec", value)


if not MYPY:
    class KubeNodePoolTemplateMetadataArgsDict(TypedDict):
        annotations: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        annotations
        """
        finalizers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        finalizers
        """
        labels: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        labels
        """
elif False:
    KubeNodePoolTemplateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeNodePoolTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 finalizers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 labels: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: annotations
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] finalizers: finalizers
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: labels
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "finalizers", finalizers)
        pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def finalizers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        finalizers
        """
        return pulumi.get(self, "finalizers")

    @finalizers.setter
    def finalizers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "finalizers", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class KubeNodePoolTemplateSpecArgsDict(TypedDict):
        taints: pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]
        """
        taints
        """
        unschedulable: pulumi.Input[_builtins.bool]
        """
        unschedulable
        """
elif False:
    KubeNodePoolTemplateSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeNodePoolTemplateSpecArgs:
    def __init__(__self__, *,
                 taints: pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]],
                 unschedulable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] taints: taints
        :param pulumi.Input[_builtins.bool] unschedulable: unschedulable
        """
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "unschedulable", unschedulable)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]:
        """
        taints
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]):
        pulumi.set(self, "taints", value)

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> pulumi.Input[_builtins.bool]:
        """
        unschedulable
        """
        return pulumi.get(self, "unschedulable")

    @unschedulable.setter
    def unschedulable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "unschedulable", value)


if not MYPY:
    class KubePrivateNetworkConfigurationArgsDict(TypedDict):
        default_vrack_gateway: pulumi.Input[_builtins.str]
        """
        If defined, all egress traffic will be routed towards this IP address, which should belong to the private network. Empty string means disabled.
        """
        private_network_routing_as_default: pulumi.Input[_builtins.bool]
        """
        Defines whether routing should default to using the nodes' private interface, instead of their public interface. Default is false.

        In order to use the gateway IP advertised by the private network subnet DHCP, the following configuration shall be used.
        """
elif False:
    KubePrivateNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubePrivateNetworkConfigurationArgs:
    def __init__(__self__, *,
                 default_vrack_gateway: pulumi.Input[_builtins.str],
                 private_network_routing_as_default: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] default_vrack_gateway: If defined, all egress traffic will be routed towards this IP address, which should belong to the private network. Empty string means disabled.
        :param pulumi.Input[_builtins.bool] private_network_routing_as_default: Defines whether routing should default to using the nodes' private interface, instead of their public interface. Default is false.
               
               In order to use the gateway IP advertised by the private network subnet DHCP, the following configuration shall be used.
        """
        pulumi.set(__self__, "default_vrack_gateway", default_vrack_gateway)
        pulumi.set(__self__, "private_network_routing_as_default", private_network_routing_as_default)

    @_builtins.property
    @pulumi.getter(name="defaultVrackGateway")
    def default_vrack_gateway(self) -> pulumi.Input[_builtins.str]:
        """
        If defined, all egress traffic will be routed towards this IP address, which should belong to the private network. Empty string means disabled.
        """
        return pulumi.get(self, "default_vrack_gateway")

    @default_vrack_gateway.setter
    def default_vrack_gateway(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_vrack_gateway", value)

    @_builtins.property
    @pulumi.getter(name="privateNetworkRoutingAsDefault")
    def private_network_routing_as_default(self) -> pulumi.Input[_builtins.bool]:
        """
        Defines whether routing should default to using the nodes' private interface, instead of their public interface. Default is false.

        In order to use the gateway IP advertised by the private network subnet DHCP, the following configuration shall be used.
        """
        return pulumi.get(self, "private_network_routing_as_default")

    @private_network_routing_as_default.setter
    def private_network_routing_as_default(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "private_network_routing_as_default", value)


if not MYPY:
    class LoadBalancerFloatingIpArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the resource
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP Address of the resource
        """
elif False:
    LoadBalancerFloatingIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerFloatingIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the resource
        :param pulumi.Input[_builtins.str] ip: IP Address of the resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the resource
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP Address of the resource
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LoadBalancerListenerArgsDict(TypedDict):
        port: pulumi.Input[_builtins.float]
        """
        Listener port
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol for the listener
        """
        allowed_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The allowed CIDRs
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the listener
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the listener
        """
        pool: NotRequired[pulumi.Input['LoadBalancerListenerPoolArgsDict']]
        """
        Listener pool
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret ID to get certificate for SSL listener creation
        """
        timeout_client_data: NotRequired[pulumi.Input[_builtins.float]]
        """
        Timeout client data of the listener
        """
        timeout_member_data: NotRequired[pulumi.Input[_builtins.float]]
        """
        Timeout member data of the listener
        """
        tls_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TLS versions of the listener
        """
elif False:
    LoadBalancerListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.float],
                 protocol: pulumi.Input[_builtins.str],
                 allowed_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 pool: Optional[pulumi.Input['LoadBalancerListenerPoolArgs']] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_client_data: Optional[pulumi.Input[_builtins.float]] = None,
                 timeout_member_data: Optional[pulumi.Input[_builtins.float]] = None,
                 tls_versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.float] port: Listener port
        :param pulumi.Input[_builtins.str] protocol: Protocol for the listener
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_cidrs: The allowed CIDRs
        :param pulumi.Input[_builtins.str] description: The description of the listener
        :param pulumi.Input[_builtins.str] name: Name of the listener
        :param pulumi.Input['LoadBalancerListenerPoolArgs'] pool: Listener pool
        :param pulumi.Input[_builtins.str] secret_id: Secret ID to get certificate for SSL listener creation
        :param pulumi.Input[_builtins.float] timeout_client_data: Timeout client data of the listener
        :param pulumi.Input[_builtins.float] timeout_member_data: Timeout member data of the listener
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tls_versions: TLS versions of the listener
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if allowed_cidrs is not None:
            pulumi.set(__self__, "allowed_cidrs", allowed_cidrs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if timeout_client_data is not None:
            pulumi.set(__self__, "timeout_client_data", timeout_client_data)
        if timeout_member_data is not None:
            pulumi.set(__self__, "timeout_member_data", timeout_member_data)
        if tls_versions is not None:
            pulumi.set(__self__, "tls_versions", tls_versions)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.float]:
        """
        Listener port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol for the listener
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="allowedCidrs")
    def allowed_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed CIDRs
        """
        return pulumi.get(self, "allowed_cidrs")

    @allowed_cidrs.setter
    def allowed_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_cidrs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the listener
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the listener
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input['LoadBalancerListenerPoolArgs']]:
        """
        Listener pool
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input['LoadBalancerListenerPoolArgs']]):
        pulumi.set(self, "pool", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret ID to get certificate for SSL listener creation
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter(name="timeoutClientData")
    def timeout_client_data(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Timeout client data of the listener
        """
        return pulumi.get(self, "timeout_client_data")

    @timeout_client_data.setter
    def timeout_client_data(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout_client_data", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMemberData")
    def timeout_member_data(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Timeout member data of the listener
        """
        return pulumi.get(self, "timeout_member_data")

    @timeout_member_data.setter
    def timeout_member_data(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout_member_data", value)

    @_builtins.property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TLS versions of the listener
        """
        return pulumi.get(self, "tls_versions")

    @tls_versions.setter
    def tls_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tls_versions", value)


if not MYPY:
    class LoadBalancerListenerPoolArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Pool algorithm to split traffic between members
        """
        health_monitor: NotRequired[pulumi.Input['LoadBalancerListenerPoolHealthMonitorArgsDict']]
        """
        Pool health monitor
        """
        members: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerPoolMemberArgsDict']]]]
        """
        Pool members
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the pool
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol for the pool
        """
        session_persistence: NotRequired[pulumi.Input['LoadBalancerListenerPoolSessionPersistenceArgsDict']]
        """
        Pool session persistence
        """
elif False:
    LoadBalancerListenerPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerPoolArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 health_monitor: Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerPoolMemberArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 session_persistence: Optional[pulumi.Input['LoadBalancerListenerPoolSessionPersistenceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] algorithm: Pool algorithm to split traffic between members
        :param pulumi.Input['LoadBalancerListenerPoolHealthMonitorArgs'] health_monitor: Pool health monitor
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerPoolMemberArgs']]] members: Pool members
        :param pulumi.Input[_builtins.str] name: Name of the pool
        :param pulumi.Input[_builtins.str] protocol: Protocol for the pool
        :param pulumi.Input['LoadBalancerListenerPoolSessionPersistenceArgs'] session_persistence: Pool session persistence
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if health_monitor is not None:
            pulumi.set(__self__, "health_monitor", health_monitor)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_persistence is not None:
            pulumi.set(__self__, "session_persistence", session_persistence)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Pool algorithm to split traffic between members
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="healthMonitor")
    def health_monitor(self) -> Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorArgs']]:
        """
        Pool health monitor
        """
        return pulumi.get(self, "health_monitor")

    @health_monitor.setter
    def health_monitor(self, value: Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorArgs']]):
        pulumi.set(self, "health_monitor", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerPoolMemberArgs']]]]:
        """
        Pool members
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerPoolMemberArgs']]]]):
        pulumi.set(self, "members", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol for the pool
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="sessionPersistence")
    def session_persistence(self) -> Optional[pulumi.Input['LoadBalancerListenerPoolSessionPersistenceArgs']]:
        """
        Pool session persistence
        """
        return pulumi.get(self, "session_persistence")

    @session_persistence.setter
    def session_persistence(self, value: Optional[pulumi.Input['LoadBalancerListenerPoolSessionPersistenceArgs']]):
        pulumi.set(self, "session_persistence", value)


if not MYPY:
    class LoadBalancerListenerPoolHealthMonitorArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[_builtins.float]]
        """
        Duration between sending probes to members, in seconds
        """
        http_configuration: NotRequired[pulumi.Input['LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgsDict']]
        """
        Monitor HTTP configuration
        """
        max_retries: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of successful checks before changing the operating status of the member to ONLINE
        """
        max_retries_down: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of allowed check failures before changing the operating status of the member to ERROR
        """
        monitor_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the monitor
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource
        """
        operating_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operating status of the resource
        """
        provisioning_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The provisioning status of the resource
        """
        timeout: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum time, in seconds, that a monitor waits to connect before it times out. This value must be less than the delay value
        """
elif False:
    LoadBalancerListenerPoolHealthMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerPoolHealthMonitorArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[_builtins.float]] = None,
                 http_configuration: Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs']] = None,
                 max_retries: Optional[pulumi.Input[_builtins.float]] = None,
                 max_retries_down: Optional[pulumi.Input[_builtins.float]] = None,
                 monitor_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 operating_status: Optional[pulumi.Input[_builtins.str]] = None,
                 provisioning_status: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] delay: Duration between sending probes to members, in seconds
        :param pulumi.Input['LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs'] http_configuration: Monitor HTTP configuration
        :param pulumi.Input[_builtins.float] max_retries: Number of successful checks before changing the operating status of the member to ONLINE
        :param pulumi.Input[_builtins.float] max_retries_down: Number of allowed check failures before changing the operating status of the member to ERROR
        :param pulumi.Input[_builtins.str] monitor_type: Type of the monitor
        :param pulumi.Input[_builtins.str] name: The name of the resource
        :param pulumi.Input[_builtins.str] operating_status: The operating status of the resource
        :param pulumi.Input[_builtins.str] provisioning_status: The provisioning status of the resource
        :param pulumi.Input[_builtins.float] timeout: Maximum time, in seconds, that a monitor waits to connect before it times out. This value must be less than the delay value
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if http_configuration is not None:
            pulumi.set(__self__, "http_configuration", http_configuration)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if max_retries_down is not None:
            pulumi.set(__self__, "max_retries_down", max_retries_down)
        if monitor_type is not None:
            pulumi.set(__self__, "monitor_type", monitor_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operating_status is not None:
            pulumi.set(__self__, "operating_status", operating_status)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Duration between sending probes to members, in seconds
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter(name="httpConfiguration")
    def http_configuration(self) -> Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs']]:
        """
        Monitor HTTP configuration
        """
        return pulumi.get(self, "http_configuration")

    @http_configuration.setter
    def http_configuration(self, value: Optional[pulumi.Input['LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs']]):
        pulumi.set(self, "http_configuration", value)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of successful checks before changing the operating status of the member to ONLINE
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_retries", value)

    @_builtins.property
    @pulumi.getter(name="maxRetriesDown")
    def max_retries_down(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of allowed check failures before changing the operating status of the member to ERROR
        """
        return pulumi.get(self, "max_retries_down")

    @max_retries_down.setter
    def max_retries_down(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_retries_down", value)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the monitor
        """
        return pulumi.get(self, "monitor_type")

    @monitor_type.setter
    def monitor_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitor_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="operatingStatus")
    def operating_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operating status of the resource
        """
        return pulumi.get(self, "operating_status")

    @operating_status.setter
    def operating_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operating_status", value)

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The provisioning status of the resource
        """
        return pulumi.get(self, "provisioning_status")

    @provisioning_status.setter
    def provisioning_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provisioning_status", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum time, in seconds, that a monitor waits to connect before it times out. This value must be less than the delay value
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain name, which be injected into the HTTP Host Header to the backend server for HTTP health check
        """
        expected_codes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status codes expected in response from the member to declare it healthy; The list of HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: * A single value, such as 200; * A list, such as 200, 202; * A range, such as 200-204
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP method that the health monitor uses for requests
        """
        http_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP version that the health monitor uses for requests
        """
        url_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP URL path of the request sent by the monitor to test the health of a backend member
        """
elif False:
    LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerPoolHealthMonitorHttpConfigurationArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 expected_codes: Optional[pulumi.Input[_builtins.str]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 http_version: Optional[pulumi.Input[_builtins.str]] = None,
                 url_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain_name: Domain name, which be injected into the HTTP Host Header to the backend server for HTTP health check
        :param pulumi.Input[_builtins.str] expected_codes: Status codes expected in response from the member to declare it healthy; The list of HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: * A single value, such as 200; * A list, such as 200, 202; * A range, such as 200-204
        :param pulumi.Input[_builtins.str] http_method: HTTP method that the health monitor uses for requests
        :param pulumi.Input[_builtins.str] http_version: HTTP version that the health monitor uses for requests
        :param pulumi.Input[_builtins.str] url_path: HTTP URL path of the request sent by the monitor to test the health of a backend member
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if expected_codes is not None:
            pulumi.set(__self__, "expected_codes", expected_codes)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain name, which be injected into the HTTP Host Header to the backend server for HTTP health check
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status codes expected in response from the member to declare it healthy; The list of HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: * A single value, such as 200; * A list, such as 200, 202; * A range, such as 200-204
        """
        return pulumi.get(self, "expected_codes")

    @expected_codes.setter
    def expected_codes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_codes", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP method that the health monitor uses for requests
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP version that the health monitor uses for requests
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_version", value)

    @_builtins.property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP URL path of the request sent by the monitor to test the health of a backend member
        """
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_path", value)


if not MYPY:
    class LoadBalancerListenerPoolMemberArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address of the resource
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the member
        """
        protocol_port: NotRequired[pulumi.Input[_builtins.float]]
        """
        Protocol port number for the resource
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        Weight of a member determines the portion of requests or connections it services compared to the other members of the pool. Between 1 and 256.
        """
elif False:
    LoadBalancerListenerPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerPoolMemberArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.float]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] address: IP address of the resource
        :param pulumi.Input[_builtins.str] name: Name of the member
        :param pulumi.Input[_builtins.float] protocol_port: Protocol port number for the resource
        :param pulumi.Input[_builtins.float] weight: Weight of a member determines the portion of requests or connections it services compared to the other members of the pool. Between 1 and 256.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address of the resource
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the member
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Protocol port number for the resource
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Weight of a member determines the portion of requests or connections it services compared to the other members of the pool. Between 1 and 256.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LoadBalancerListenerPoolSessionPersistenceArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cookie name, only applicable to session persistence through cookie
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of session persistence
        """
elif False:
    LoadBalancerListenerPoolSessionPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerPoolSessionPersistenceArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie_name: Cookie name, only applicable to session persistence through cookie
        :param pulumi.Input[_builtins.str] type: Type of session persistence
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cookie name, only applicable to session persistence through cookie
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of session persistence
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadBalancerNetworkArgsDict(TypedDict):
        private: pulumi.Input['LoadBalancerNetworkPrivateArgsDict']
        """
        Information to private network
        """
elif False:
    LoadBalancerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkArgs:
    def __init__(__self__, *,
                 private: pulumi.Input['LoadBalancerNetworkPrivateArgs']):
        """
        :param pulumi.Input['LoadBalancerNetworkPrivateArgs'] private: Information to private network
        """
        pulumi.set(__self__, "private", private)

    @_builtins.property
    @pulumi.getter
    def private(self) -> pulumi.Input['LoadBalancerNetworkPrivateArgs']:
        """
        Information to private network
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: pulumi.Input['LoadBalancerNetworkPrivateArgs']):
        pulumi.set(self, "private", value)


if not MYPY:
    class LoadBalancerNetworkPrivateArgsDict(TypedDict):
        network: pulumi.Input['LoadBalancerNetworkPrivateNetworkArgsDict']
        """
        Network to associate
        """
        floating_ip: NotRequired[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpArgsDict']]
        """
        Floating IP to associate
        """
        floating_ip_create: NotRequired[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpCreateArgsDict']]
        """
        Floating IP to create
        """
        gateway: NotRequired[pulumi.Input['LoadBalancerNetworkPrivateGatewayArgsDict']]
        """
        Gateway to associate
        """
        gateway_create: NotRequired[pulumi.Input['LoadBalancerNetworkPrivateGatewayCreateArgsDict']]
        """
        Gateway to create
        """
elif False:
    LoadBalancerNetworkPrivateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateArgs:
    def __init__(__self__, *,
                 network: pulumi.Input['LoadBalancerNetworkPrivateNetworkArgs'],
                 floating_ip: Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpArgs']] = None,
                 floating_ip_create: Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpCreateArgs']] = None,
                 gateway: Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayArgs']] = None,
                 gateway_create: Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayCreateArgs']] = None):
        """
        :param pulumi.Input['LoadBalancerNetworkPrivateNetworkArgs'] network: Network to associate
        :param pulumi.Input['LoadBalancerNetworkPrivateFloatingIpArgs'] floating_ip: Floating IP to associate
        :param pulumi.Input['LoadBalancerNetworkPrivateFloatingIpCreateArgs'] floating_ip_create: Floating IP to create
        :param pulumi.Input['LoadBalancerNetworkPrivateGatewayArgs'] gateway: Gateway to associate
        :param pulumi.Input['LoadBalancerNetworkPrivateGatewayCreateArgs'] gateway_create: Gateway to create
        """
        pulumi.set(__self__, "network", network)
        if floating_ip is not None:
            pulumi.set(__self__, "floating_ip", floating_ip)
        if floating_ip_create is not None:
            pulumi.set(__self__, "floating_ip_create", floating_ip_create)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway_create is not None:
            pulumi.set(__self__, "gateway_create", gateway_create)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input['LoadBalancerNetworkPrivateNetworkArgs']:
        """
        Network to associate
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input['LoadBalancerNetworkPrivateNetworkArgs']):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="floatingIp")
    def floating_ip(self) -> Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpArgs']]:
        """
        Floating IP to associate
        """
        return pulumi.get(self, "floating_ip")

    @floating_ip.setter
    def floating_ip(self, value: Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpArgs']]):
        pulumi.set(self, "floating_ip", value)

    @_builtins.property
    @pulumi.getter(name="floatingIpCreate")
    def floating_ip_create(self) -> Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpCreateArgs']]:
        """
        Floating IP to create
        """
        return pulumi.get(self, "floating_ip_create")

    @floating_ip_create.setter
    def floating_ip_create(self, value: Optional[pulumi.Input['LoadBalancerNetworkPrivateFloatingIpCreateArgs']]):
        pulumi.set(self, "floating_ip_create", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayArgs']]:
        """
        Gateway to associate
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayArgs']]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter(name="gatewayCreate")
    def gateway_create(self) -> Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayCreateArgs']]:
        """
        Gateway to create
        """
        return pulumi.get(self, "gateway_create")

    @gateway_create.setter
    def gateway_create(self, value: Optional[pulumi.Input['LoadBalancerNetworkPrivateGatewayCreateArgs']]):
        pulumi.set(self, "gateway_create", value)


if not MYPY:
    class LoadBalancerNetworkPrivateFloatingIpArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the floatingIp
        """
elif False:
    LoadBalancerNetworkPrivateFloatingIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateFloatingIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the floatingIp
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the floatingIp
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LoadBalancerNetworkPrivateFloatingIpCreateArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description for the floatingIp
        """
elif False:
    LoadBalancerNetworkPrivateFloatingIpCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateFloatingIpCreateArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description for the floatingIp
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description for the floatingIp
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LoadBalancerNetworkPrivateGatewayArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the gateway
        """
elif False:
    LoadBalancerNetworkPrivateGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateGatewayArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the gateway
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the gateway
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LoadBalancerNetworkPrivateGatewayCreateArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model of the gateway
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the gateway
        """
elif False:
    LoadBalancerNetworkPrivateGatewayCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateGatewayCreateArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: Model of the gateway
        :param pulumi.Input[_builtins.str] name: Name of the gateway
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model of the gateway
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the gateway
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LoadBalancerNetworkPrivateNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Private network ID
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        Subnet ID
        """
elif False:
    LoadBalancerNetworkPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerNetworkPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Private network ID
        :param pulumi.Input[_builtins.str] subnet_id: Subnet ID
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Private network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NetworkPrivateRegionsAttributeArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        the status of the network. should be normally set to 'ACTIVE'.
        """
        openstackid: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NetworkPrivateRegionsAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPrivateRegionsAttributeArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 openstackid: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: the status of the network. should be normally set to 'ACTIVE'.
        """
        pulumi.set(__self__, "status", status)
        if openstackid is not None:
            pulumi.set(__self__, "openstackid", openstackid)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        the status of the network. should be normally set to 'ACTIVE'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def openstackid(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "openstackid")

    @openstackid.setter
    def openstackid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "openstackid", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class NetworkPrivateRegionsStatusArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        the status of the network. should be normally set to 'ACTIVE'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NetworkPrivateRegionsStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPrivateRegionsStatusArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: the status of the network. should be normally set to 'ACTIVE'.
        """
        pulumi.set(__self__, "status", status)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        the status of the network. should be normally set to 'ACTIVE'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class NetworkPrivateSubnetIpPoolArgsDict(TypedDict):
        dhcp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP. Changing this forces a new resource to be created. Defaults to false.
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last ip for this region. Changing this value recreates the subnet.
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global network in CIDR format. Changing this value recreates the subnet
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region in which the network subnet will be created. Ex.: "GRA1". Changing this value recreates the resource.
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        First ip for this region. Changing this value recreates the subnet.
        """
elif False:
    NetworkPrivateSubnetIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPrivateSubnetIpPoolArgs:
    def __init__(__self__, *,
                 dhcp: Optional[pulumi.Input[_builtins.bool]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] dhcp: Enable DHCP. Changing this forces a new resource to be created. Defaults to false.
        :param pulumi.Input[_builtins.str] end: Last ip for this region. Changing this value recreates the subnet.
        :param pulumi.Input[_builtins.str] network: Global network in CIDR format. Changing this value recreates the subnet
        :param pulumi.Input[_builtins.str] region: The region in which the network subnet will be created. Ex.: "GRA1". Changing this value recreates the resource.
        :param pulumi.Input[_builtins.str] start: First ip for this region. Changing this value recreates the subnet.
        """
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP. Changing this forces a new resource to be created. Defaults to false.
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dhcp", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last ip for this region. Changing this value recreates the subnet.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global network in CIDR format. Changing this value recreates the subnet
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region in which the network subnet will be created. Ex.: "GRA1". Changing this value recreates the resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        First ip for this region. Changing this value recreates the subnet.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NetworkPrivateSubnetV2AllocationPoolArgsDict(TypedDict):
        end: pulumi.Input[_builtins.str]
        start: pulumi.Input[_builtins.str]
elif False:
    NetworkPrivateSubnetV2AllocationPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPrivateSubnetV2AllocationPoolArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[_builtins.str],
                 start: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NetworkPrivateSubnetV2HostRouteArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        nexthop: pulumi.Input[_builtins.str]
elif False:
    NetworkPrivateSubnetV2HostRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPrivateSubnetV2HostRouteArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 nexthop: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "nexthop", nexthop)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nexthop", value)


if not MYPY:
    class ProjectOrderArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        date
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectOrderDetailArgsDict']]]]
        """
        Information about a Bill entry
        """
        expiration_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        expiration date
        """
        order_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        order id, the same as the `id`
        """
elif False:
    ProjectOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectOrderArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectOrderDetailArgs']]]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 order_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] date: date
        :param pulumi.Input[Sequence[pulumi.Input['ProjectOrderDetailArgs']]] details: Information about a Bill entry
        :param pulumi.Input[_builtins.str] expiration_date: expiration date
        :param pulumi.Input[_builtins.int] order_id: order id, the same as the `id`
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if order_id is not None:
            pulumi.set(__self__, "order_id", order_id)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        date
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectOrderDetailArgs']]]]:
        """
        Information about a Bill entry
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectOrderDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        expiration date
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="orderId")
    def order_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        order id, the same as the `id`
        """
        return pulumi.get(self, "order_id")

    @order_id.setter
    def order_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "order_id", value)


if not MYPY:
    class ProjectOrderDetailArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description associated with the user.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        expiration date
        """
        order_detail_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        order detail id
        """
        quantity: NotRequired[pulumi.Input[_builtins.str]]
        """
        quantity
        """
elif False:
    ProjectOrderDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectOrderDetailArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 order_detail_id: Optional[pulumi.Input[_builtins.int]] = None,
                 quantity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A description associated with the user.
        :param pulumi.Input[_builtins.str] domain: expiration date
        :param pulumi.Input[_builtins.int] order_detail_id: order detail id
        :param pulumi.Input[_builtins.str] quantity: quantity
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if order_detail_id is not None:
            pulumi.set(__self__, "order_detail_id", order_detail_id)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description associated with the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        expiration date
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="orderDetailId")
    def order_detail_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        order detail id
        """
        return pulumi.get(self, "order_detail_id")

    @order_detail_id.setter
    def order_detail_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "order_detail_id", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        quantity
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quantity", value)


if not MYPY:
    class ProjectPlanArgsDict(TypedDict):
        duration: pulumi.Input[_builtins.str]
        """
        duration
        """
        plan_code: pulumi.Input[_builtins.str]
        """
        Plan code. This value must be adapted depending on your `OVH_ENDPOINT` value. It's `project.2018` for `ovh-{eu,ca}` and `project` when using `ovh-us`.
        """
        pricing_mode: pulumi.Input[_builtins.str]
        """
        Pricing model identifier
        """
        catalog_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Catalog name
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectPlanConfigurationArgsDict']]]]
        """
        Representation of a configuration item for personalizing product
        """
elif False:
    ProjectPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPlanArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.str],
                 plan_code: pulumi.Input[_builtins.str],
                 pricing_mode: pulumi.Input[_builtins.str],
                 catalog_name: Optional[pulumi.Input[_builtins.str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] duration: duration
        :param pulumi.Input[_builtins.str] plan_code: Plan code. This value must be adapted depending on your `OVH_ENDPOINT` value. It's `project.2018` for `ovh-{eu,ca}` and `project` when using `ovh-us`.
        :param pulumi.Input[_builtins.str] pricing_mode: Pricing model identifier
        :param pulumi.Input[_builtins.str] catalog_name: Catalog name
        :param pulumi.Input[Sequence[pulumi.Input['ProjectPlanConfigurationArgs']]] configurations: Representation of a configuration item for personalizing product
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "plan_code", plan_code)
        pulumi.set(__self__, "pricing_mode", pricing_mode)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.str]:
        """
        duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="planCode")
    def plan_code(self) -> pulumi.Input[_builtins.str]:
        """
        Plan code. This value must be adapted depending on your `OVH_ENDPOINT` value. It's `project.2018` for `ovh-{eu,ca}` and `project` when using `ovh-us`.
        """
        return pulumi.get(self, "plan_code")

    @plan_code.setter
    def plan_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan_code", value)

    @_builtins.property
    @pulumi.getter(name="pricingMode")
    def pricing_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Pricing model identifier
        """
        return pulumi.get(self, "pricing_mode")

    @pricing_mode.setter
    def pricing_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pricing_mode", value)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Catalog name
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_name", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanConfigurationArgs']]]]:
        """
        Representation of a configuration item for personalizing product
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)


if not MYPY:
    class ProjectPlanConfigurationArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        Identifier of the resource
        """
        value: pulumi.Input[_builtins.str]
        """
        Path to the resource in API.OVH.COM
        """
elif False:
    ProjectPlanConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPlanConfigurationArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: Identifier of the resource
        :param pulumi.Input[_builtins.str] value: Path to the resource in API.OVH.COM
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the resource
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Path to the resource in API.OVH.COM
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectPlanOptionArgsDict(TypedDict):
        duration: pulumi.Input[_builtins.str]
        """
        duration
        """
        plan_code: pulumi.Input[_builtins.str]
        """
        Plan code
        """
        pricing_mode: pulumi.Input[_builtins.str]
        """
        Pricing model identifier
        """
        catalog_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Catalog name
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectPlanOptionConfigurationArgsDict']]]]
        """
        Representation of a configuration item for personalizing product
        """
elif False:
    ProjectPlanOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPlanOptionArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.str],
                 plan_code: pulumi.Input[_builtins.str],
                 pricing_mode: pulumi.Input[_builtins.str],
                 catalog_name: Optional[pulumi.Input[_builtins.str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanOptionConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] duration: duration
        :param pulumi.Input[_builtins.str] plan_code: Plan code
        :param pulumi.Input[_builtins.str] pricing_mode: Pricing model identifier
        :param pulumi.Input[_builtins.str] catalog_name: Catalog name
        :param pulumi.Input[Sequence[pulumi.Input['ProjectPlanOptionConfigurationArgs']]] configurations: Representation of a configuration item for personalizing product
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "plan_code", plan_code)
        pulumi.set(__self__, "pricing_mode", pricing_mode)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.str]:
        """
        duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="planCode")
    def plan_code(self) -> pulumi.Input[_builtins.str]:
        """
        Plan code
        """
        return pulumi.get(self, "plan_code")

    @plan_code.setter
    def plan_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan_code", value)

    @_builtins.property
    @pulumi.getter(name="pricingMode")
    def pricing_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Pricing model identifier
        """
        return pulumi.get(self, "pricing_mode")

    @pricing_mode.setter
    def pricing_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pricing_mode", value)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Catalog name
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_name", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanOptionConfigurationArgs']]]]:
        """
        Representation of a configuration item for personalizing product
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectPlanOptionConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)


if not MYPY:
    class ProjectPlanOptionConfigurationArgsDict(TypedDict):
        label: pulumi.Input[_builtins.str]
        """
        Identifier of the resource
        """
        value: pulumi.Input[_builtins.str]
        """
        Path to the resource in API.OVH.COM
        """
elif False:
    ProjectPlanOptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPlanOptionConfigurationArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] label: Identifier of the resource
        :param pulumi.Input[_builtins.str] value: Path to the resource in API.OVH.COM
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the resource
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Path to the resource in API.OVH.COM
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectRegionServiceArgsDict(TypedDict):
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint URL
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service name
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service status
        """
elif False:
    ProjectRegionServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRegionServiceArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Endpoint URL
        :param pulumi.Input[_builtins.str] name: Service name
        :param pulumi.Input[_builtins.str] status: Service status
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint URL
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RancherCurrentStateArgsDict(TypedDict):
        bootstrap_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bootstrap password of the managed Rancher service, returned only on creation
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RancherCurrentStateIpRestrictionArgsDict']]]]
        """
        List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the managed Rancher service
        """
        networking: NotRequired[pulumi.Input['RancherCurrentStateNetworkingArgsDict']]
        """
        Networking properties of a managed Rancher service
        """
        plan: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plan of the managed Rancher service
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region of the managed Rancher service
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the managed Rancher service
        """
        usage: NotRequired[pulumi.Input['RancherCurrentStateUsageArgsDict']]
        """
        Latest metrics regarding the usage of the managed Rancher service
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the managed Rancher service
        """
elif False:
    RancherCurrentStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherCurrentStateArgs:
    def __init__(__self__, *,
                 bootstrap_password: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['RancherCurrentStateIpRestrictionArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 networking: Optional[pulumi.Input['RancherCurrentStateNetworkingArgs']] = None,
                 plan: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 usage: Optional[pulumi.Input['RancherCurrentStateUsageArgs']] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bootstrap_password: Bootstrap password of the managed Rancher service, returned only on creation
        :param pulumi.Input[Sequence[pulumi.Input['RancherCurrentStateIpRestrictionArgs']]] ip_restrictions: List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        :param pulumi.Input[_builtins.str] name: Name of the managed Rancher service
        :param pulumi.Input['RancherCurrentStateNetworkingArgs'] networking: Networking properties of a managed Rancher service
        :param pulumi.Input[_builtins.str] plan: Plan of the managed Rancher service
        :param pulumi.Input[_builtins.str] region: Region of the managed Rancher service
        :param pulumi.Input[_builtins.str] url: URL of the managed Rancher service
        :param pulumi.Input['RancherCurrentStateUsageArgs'] usage: Latest metrics regarding the usage of the managed Rancher service
        :param pulumi.Input[_builtins.str] version: Version of the managed Rancher service
        """
        if bootstrap_password is not None:
            pulumi.set(__self__, "bootstrap_password", bootstrap_password)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="bootstrapPassword")
    def bootstrap_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bootstrap password of the managed Rancher service, returned only on creation
        """
        return pulumi.get(self, "bootstrap_password")

    @bootstrap_password.setter
    def bootstrap_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bootstrap_password", value)

    @_builtins.property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RancherCurrentStateIpRestrictionArgs']]]]:
        """
        List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RancherCurrentStateIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the managed Rancher service
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['RancherCurrentStateNetworkingArgs']]:
        """
        Networking properties of a managed Rancher service
        """
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['RancherCurrentStateNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plan of the managed Rancher service
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region of the managed Rancher service
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the managed Rancher service
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input['RancherCurrentStateUsageArgs']]:
        """
        Latest metrics regarding the usage of the managed Rancher service
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input['RancherCurrentStateUsageArgs']]):
        pulumi.set(self, "usage", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the managed Rancher service
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RancherCurrentStateIpRestrictionArgsDict(TypedDict):
        cidr_block: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the allowed CIDR block
        """
elif False:
    RancherCurrentStateIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherCurrentStateIpRestrictionArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr_block: Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        :param pulumi.Input[_builtins.str] description: Description of the allowed CIDR block
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_block", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the allowed CIDR block
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class RancherCurrentStateNetworkingArgsDict(TypedDict):
        egress_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.
        """
elif False:
    RancherCurrentStateNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherCurrentStateNetworkingArgs:
    def __init__(__self__, *,
                 egress_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] egress_cidr_blocks: Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.
        """
        if egress_cidr_blocks is not None:
            pulumi.set(__self__, "egress_cidr_blocks", egress_cidr_blocks)

    @_builtins.property
    @pulumi.getter(name="egressCidrBlocks")
    def egress_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.
        """
        return pulumi.get(self, "egress_cidr_blocks")

    @egress_cidr_blocks.setter
    def egress_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "egress_cidr_blocks", value)


if not MYPY:
    class RancherCurrentStateUsageArgsDict(TypedDict):
        datetime: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date of the sample
        """
        orchestrated_vcpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters
        """
elif False:
    RancherCurrentStateUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherCurrentStateUsageArgs:
    def __init__(__self__, *,
                 datetime: Optional[pulumi.Input[_builtins.str]] = None,
                 orchestrated_vcpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] datetime: Date of the sample
        :param pulumi.Input[_builtins.float] orchestrated_vcpus: Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters
        """
        if datetime is not None:
            pulumi.set(__self__, "datetime", datetime)
        if orchestrated_vcpus is not None:
            pulumi.set(__self__, "orchestrated_vcpus", orchestrated_vcpus)

    @_builtins.property
    @pulumi.getter
    def datetime(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date of the sample
        """
        return pulumi.get(self, "datetime")

    @datetime.setter
    def datetime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datetime", value)

    @_builtins.property
    @pulumi.getter(name="orchestratedVcpus")
    def orchestrated_vcpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters
        """
        return pulumi.get(self, "orchestrated_vcpus")

    @orchestrated_vcpus.setter
    def orchestrated_vcpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "orchestrated_vcpus", value)


if not MYPY:
    class RancherCurrentTaskArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the current task
        """
        link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Link to the task details
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current global status of the current task
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the current task
        """
elif False:
    RancherCurrentTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherCurrentTaskArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 link: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier of the current task
        :param pulumi.Input[_builtins.str] link: Link to the task details
        :param pulumi.Input[_builtins.str] status: Current global status of the current task
        :param pulumi.Input[_builtins.str] type: Type of the current task
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the current task
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Link to the task details
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current global status of the current task
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the current task
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RancherTargetSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the managed Rancher service
        """
        plan: pulumi.Input[_builtins.str]
        """
        Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RancherTargetSpecIpRestrictionArgsDict']]]]
        """
        List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using ovh*cloud*project*rancher*version datasource. Default is the latest version.
        """
elif False:
    RancherTargetSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherTargetSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 plan: pulumi.Input[_builtins.str],
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['RancherTargetSpecIpRestrictionArgs']]]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the managed Rancher service
        :param pulumi.Input[_builtins.str] plan: Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan
        :param pulumi.Input[Sequence[pulumi.Input['RancherTargetSpecIpRestrictionArgs']]] ip_restrictions: List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        :param pulumi.Input[_builtins.str] version: Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using ovh*cloud*project*rancher*version datasource. Default is the latest version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan", plan)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the managed Rancher service
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> pulumi.Input[_builtins.str]:
        """
        Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RancherTargetSpecIpRestrictionArgs']]]]:
        """
        List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RancherTargetSpecIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using ovh*cloud*project*rancher*version datasource. Default is the latest version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RancherTargetSpecIpRestrictionArgsDict(TypedDict):
        cidr_block: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the allowed CIDR block
        """
elif False:
    RancherTargetSpecIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RancherTargetSpecIpRestrictionArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr_block: Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        :param pulumi.Input[_builtins.str] description: Description of the allowed CIDR block
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_block", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the allowed CIDR block
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class RegionNetworkSubnetArgsDict(TypedDict):
        cidr: pulumi.Input[_builtins.str]
        """
        Subnet range in CIDR notation
        """
        enable_dhcp: pulumi.Input[_builtins.bool]
        """
        Enable DHCP for the subnet
        """
        enable_gateway_ip: pulumi.Input[_builtins.bool]
        """
        Set a gateway ip for the subnet
        """
        ip_version: pulumi.Input[_builtins.float]
        """
        IP version
        """
        allocation_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetAllocationPoolArgsDict']]]]
        """
        List of IP pools allocated in subnet
        """
        dns_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        DNS nameservers
        """
        gateway_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gateway IP
        """
        host_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetHostRouteArgsDict']]]]
        """
        Host routes
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet name
        """
        use_default_public_dnsresolver: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use default DNS
        """
elif False:
    RegionNetworkSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegionNetworkSubnetArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str],
                 enable_dhcp: pulumi.Input[_builtins.bool],
                 enable_gateway_ip: pulumi.Input[_builtins.bool],
                 ip_version: pulumi.Input[_builtins.float],
                 allocation_pools: Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetAllocationPoolArgs']]]] = None,
                 dns_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 gateway_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 host_routes: Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetHostRouteArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 use_default_public_dnsresolver: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: Subnet range in CIDR notation
        :param pulumi.Input[_builtins.bool] enable_dhcp: Enable DHCP for the subnet
        :param pulumi.Input[_builtins.bool] enable_gateway_ip: Set a gateway ip for the subnet
        :param pulumi.Input[_builtins.float] ip_version: IP version
        :param pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetAllocationPoolArgs']]] allocation_pools: List of IP pools allocated in subnet
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_name_servers: DNS nameservers
        :param pulumi.Input[_builtins.str] gateway_ip: Gateway IP
        :param pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetHostRouteArgs']]] host_routes: Host routes
        :param pulumi.Input[_builtins.str] name: Subnet name
        :param pulumi.Input[_builtins.bool] use_default_public_dnsresolver: Use default DNS
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "enable_dhcp", enable_dhcp)
        pulumi.set(__self__, "enable_gateway_ip", enable_gateway_ip)
        pulumi.set(__self__, "ip_version", ip_version)
        if allocation_pools is not None:
            pulumi.set(__self__, "allocation_pools", allocation_pools)
        if dns_name_servers is not None:
            pulumi.set(__self__, "dns_name_servers", dns_name_servers)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if host_routes is not None:
            pulumi.set(__self__, "host_routes", host_routes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if use_default_public_dnsresolver is not None:
            pulumi.set(__self__, "use_default_public_dnsresolver", use_default_public_dnsresolver)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet range in CIDR notation
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter(name="enableDhcp")
    def enable_dhcp(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable DHCP for the subnet
        """
        return pulumi.get(self, "enable_dhcp")

    @enable_dhcp.setter
    def enable_dhcp(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_dhcp", value)

    @_builtins.property
    @pulumi.getter(name="enableGatewayIp")
    def enable_gateway_ip(self) -> pulumi.Input[_builtins.bool]:
        """
        Set a gateway ip for the subnet
        """
        return pulumi.get(self, "enable_gateway_ip")

    @enable_gateway_ip.setter
    def enable_gateway_ip(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_gateway_ip", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.float]:
        """
        IP version
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter(name="allocationPools")
    def allocation_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetAllocationPoolArgs']]]]:
        """
        List of IP pools allocated in subnet
        """
        return pulumi.get(self, "allocation_pools")

    @allocation_pools.setter
    def allocation_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetAllocationPoolArgs']]]]):
        pulumi.set(self, "allocation_pools", value)

    @_builtins.property
    @pulumi.getter(name="dnsNameServers")
    def dns_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        DNS nameservers
        """
        return pulumi.get(self, "dns_name_servers")

    @dns_name_servers.setter
    def dns_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_name_servers", value)

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gateway IP
        """
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway_ip", value)

    @_builtins.property
    @pulumi.getter(name="hostRoutes")
    def host_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetHostRouteArgs']]]]:
        """
        Host routes
        """
        return pulumi.get(self, "host_routes")

    @host_routes.setter
    def host_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegionNetworkSubnetHostRouteArgs']]]]):
        pulumi.set(self, "host_routes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultPublicDnsresolver")
    def use_default_public_dnsresolver(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use default DNS
        """
        return pulumi.get(self, "use_default_public_dnsresolver")

    @use_default_public_dnsresolver.setter
    def use_default_public_dnsresolver(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_default_public_dnsresolver", value)


if not MYPY:
    class RegionNetworkSubnetAllocationPoolArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last IP for the pool (eg: 192.168.1.24)
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        First IP for the pool (eg: 192.168.1.12)
        """
elif False:
    RegionNetworkSubnetAllocationPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegionNetworkSubnetAllocationPoolArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end: Last IP for the pool (eg: 192.168.1.24)
        :param pulumi.Input[_builtins.str] start: First IP for the pool (eg: 192.168.1.12)
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last IP for the pool (eg: 192.168.1.24)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        First IP for the pool (eg: 192.168.1.12)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class RegionNetworkSubnetHostRouteArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host route destination (eg: 192.168.1.0/24)
        """
        next_hop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host route next hop (eg: 192.168.1.254)
        """
elif False:
    RegionNetworkSubnetHostRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegionNetworkSubnetHostRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 next_hop: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Host route destination (eg: 192.168.1.0/24)
        :param pulumi.Input[_builtins.str] next_hop: Host route next hop (eg: 192.168.1.254)
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host route destination (eg: 192.168.1.0/24)
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host route next hop (eg: 192.168.1.254)
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_hop", value)


if not MYPY:
    class StorageEncryptionArgsDict(TypedDict):
        sse_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Encryption algorithm
        """
elif False:
    StorageEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageEncryptionArgs:
    def __init__(__self__, *,
                 sse_algorithm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Encryption algorithm
        """
        if sse_algorithm is not None:
            pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Encryption algorithm
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sse_algorithm", value)


if not MYPY:
    class StorageObjectArgsDict(TypedDict):
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        ETag
        """
        is_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this object is a delete marker
        """
        is_latest: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this is the latest version of the object
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
        last_modified: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last modification date
        """
        size: NotRequired[pulumi.Input[_builtins.float]]
        """
        Size (bytes)
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Storage class
        """
        version_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version ID of the object
        """
elif False:
    StorageObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageObjectArgs:
    def __init__(__self__, *,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 is_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_latest: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modified: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.float]] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None,
                 version_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] etag: ETag
        :param pulumi.Input[_builtins.bool] is_delete_marker: Whether this object is a delete marker
        :param pulumi.Input[_builtins.bool] is_latest: Whether this is the latest version of the object
        :param pulumi.Input[_builtins.str] key: Key
        :param pulumi.Input[_builtins.str] last_modified: Last modification date
        :param pulumi.Input[_builtins.float] size: Size (bytes)
        :param pulumi.Input[_builtins.str] storage_class: Storage class
        :param pulumi.Input[_builtins.str] version_id: Version ID of the object
        """
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if is_delete_marker is not None:
            pulumi.set(__self__, "is_delete_marker", is_delete_marker)
        if is_latest is not None:
            pulumi.set(__self__, "is_latest", is_latest)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_modified is not None:
            pulumi.set(__self__, "last_modified", last_modified)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ETag
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="isDeleteMarker")
    def is_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this object is a delete marker
        """
        return pulumi.get(self, "is_delete_marker")

    @is_delete_marker.setter
    def is_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_delete_marker", value)

    @_builtins.property
    @pulumi.getter(name="isLatest")
    def is_latest(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this is the latest version of the object
        """
        return pulumi.get(self, "is_latest")

    @is_latest.setter
    def is_latest(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_latest", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last modification date
        """
        return pulumi.get(self, "last_modified")

    @last_modified.setter
    def last_modified(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Size (bytes)
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Storage class
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version ID of the object
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class StorageReplicationArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageReplicationRuleArgsDict']]]]
        """
        Replication rules
        """
elif False:
    StorageReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageReplicationArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['StorageReplicationRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StorageReplicationRuleArgs']]] rules: Replication rules
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageReplicationRuleArgs']]]]:
        """
        Replication rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageReplicationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class StorageReplicationRuleArgsDict(TypedDict):
        delete_marker_replication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Delete marker replication
        """
        destination: NotRequired[pulumi.Input['StorageReplicationRuleDestinationArgsDict']]
        """
        Rule destination configuration
        """
        filter: NotRequired[pulumi.Input['StorageReplicationRuleFilterArgsDict']]
        """
        Rule filters
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule ID
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Rule priority
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule status
        """
elif False:
    StorageReplicationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageReplicationRuleArgs:
    def __init__(__self__, *,
                 delete_marker_replication: Optional[pulumi.Input[_builtins.str]] = None,
                 destination: Optional[pulumi.Input['StorageReplicationRuleDestinationArgs']] = None,
                 filter: Optional[pulumi.Input['StorageReplicationRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete_marker_replication: Delete marker replication
        :param pulumi.Input['StorageReplicationRuleDestinationArgs'] destination: Rule destination configuration
        :param pulumi.Input['StorageReplicationRuleFilterArgs'] filter: Rule filters
        :param pulumi.Input[_builtins.str] id: Rule ID
        :param pulumi.Input[_builtins.float] priority: Rule priority
        :param pulumi.Input[_builtins.str] status: Rule status
        """
        if delete_marker_replication is not None:
            pulumi.set(__self__, "delete_marker_replication", delete_marker_replication)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Delete marker replication
        """
        return pulumi.get(self, "delete_marker_replication")

    @delete_marker_replication.setter
    def delete_marker_replication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_marker_replication", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['StorageReplicationRuleDestinationArgs']]:
        """
        Rule destination configuration
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['StorageReplicationRuleDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['StorageReplicationRuleFilterArgs']]:
        """
        Rule filters
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['StorageReplicationRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Rule priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class StorageReplicationRuleDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Destination bucket name
        """
        region: pulumi.Input[_builtins.str]
        """
        Destination region
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination storage class
        """
elif False:
    StorageReplicationRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageReplicationRuleDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Destination bucket name
        :param pulumi.Input[_builtins.str] region: Destination region
        :param pulumi.Input[_builtins.str] storage_class: Destination storage class
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Destination bucket name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Destination region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination storage class
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class StorageReplicationRuleFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix filter
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags filter
        """
elif False:
    StorageReplicationRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageReplicationRuleFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Prefix filter
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags filter
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix filter
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags filter
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class StorageVersioningArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Versioning status
        """
elif False:
    StorageVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageVersioningArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Versioning status
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Versioning status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class UserRoleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description associated with the user.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        id of the role
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        name of the role
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of permissions associated with the role
        """
elif False:
    UserRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserRoleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A description associated with the user.
        :param pulumi.Input[_builtins.str] id: id of the role
        :param pulumi.Input[_builtins.str] name: name of the role
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: list of permissions associated with the role
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description associated with the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        id of the role
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        name of the role
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of permissions associated with the role
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class VolumeSubOperationArgsDict(TypedDict):
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Affected resource of the sub-operation
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The started date of the sub-operation
        """
elif False:
    VolumeSubOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSubOperationArgs:
    def __init__(__self__, *,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_id: Affected resource of the sub-operation
        :param pulumi.Input[_builtins.str] resource_type: The started date of the sub-operation
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Affected resource of the sub-operation
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The started date of the sub-operation
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class GetKubeCustomizationArgsDict(TypedDict):
        apiservers: Sequence['GetKubeCustomizationApiserverArgsDict']
        """
        Kubernetes API server customization
        """
elif False:
    GetKubeCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationArgs:
    def __init__(__self__, *,
                 apiservers: Sequence['GetKubeCustomizationApiserverArgs']):
        """
        :param Sequence['GetKubeCustomizationApiserverArgs'] apiservers: Kubernetes API server customization
        """
        if apiservers is not None:
            warnings.warn("""Use customization_apiserver instead""", DeprecationWarning)
            pulumi.log.warn("""apiservers is deprecated: Use customization_apiserver instead""")
        pulumi.set(__self__, "apiservers", apiservers)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use customization_apiserver instead""")
    def apiservers(self) -> Sequence['GetKubeCustomizationApiserverArgs']:
        """
        Kubernetes API server customization
        """
        return pulumi.get(self, "apiservers")

    @apiservers.setter
    def apiservers(self, value: Sequence['GetKubeCustomizationApiserverArgs']):
        pulumi.set(self, "apiservers", value)


if not MYPY:
    class GetKubeCustomizationApiserverArgsDict(TypedDict):
        admissionplugins: Sequence['GetKubeCustomizationApiserverAdmissionpluginArgsDict']
        """
        Kubernetes API server admission plugins customization
        """
elif False:
    GetKubeCustomizationApiserverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationApiserverArgs:
    def __init__(__self__, *,
                 admissionplugins: Sequence['GetKubeCustomizationApiserverAdmissionpluginArgs']):
        """
        :param Sequence['GetKubeCustomizationApiserverAdmissionpluginArgs'] admissionplugins: Kubernetes API server admission plugins customization
        """
        pulumi.set(__self__, "admissionplugins", admissionplugins)

    @_builtins.property
    @pulumi.getter
    def admissionplugins(self) -> Sequence['GetKubeCustomizationApiserverAdmissionpluginArgs']:
        """
        Kubernetes API server admission plugins customization
        """
        return pulumi.get(self, "admissionplugins")

    @admissionplugins.setter
    def admissionplugins(self, value: Sequence['GetKubeCustomizationApiserverAdmissionpluginArgs']):
        pulumi.set(self, "admissionplugins", value)


if not MYPY:
    class GetKubeCustomizationApiserverAdmissionpluginArgsDict(TypedDict):
        disableds: Sequence[_builtins.str]
        """
        Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        """
        enableds: Sequence[_builtins.str]
        """
        Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
elif False:
    GetKubeCustomizationApiserverAdmissionpluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationApiserverAdmissionpluginArgs:
    def __init__(__self__, *,
                 disableds: Sequence[_builtins.str],
                 enableds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] disableds: Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        :param Sequence[_builtins.str] enableds: Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
        pulumi.set(__self__, "disableds", disableds)
        pulumi.set(__self__, "enableds", enableds)

    @_builtins.property
    @pulumi.getter
    def disableds(self) -> Sequence[_builtins.str]:
        """
        Array of admission plugins disabled, default is [] and only AlwaysPulImages can be disabled at this time.
        """
        return pulumi.get(self, "disableds")

    @disableds.setter
    def disableds(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "disableds", value)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Sequence[_builtins.str]:
        """
        Array of admission plugins enabled, default is ["NodeRestriction","AlwaysPulImages"] and only these admission plugins can be enabled at this time.
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "enableds", value)


if not MYPY:
    class GetKubeCustomizationKubeProxyArgsDict(TypedDict):
        iptables: NotRequired['GetKubeCustomizationKubeProxyIptablesArgsDict']
        """
        Kubernetes cluster kube-proxy customization of iptables specific config.
        """
        ipvs: NotRequired['GetKubeCustomizationKubeProxyIpvsArgsDict']
        """
        Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
elif False:
    GetKubeCustomizationKubeProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationKubeProxyArgs:
    def __init__(__self__, *,
                 iptables: Optional['GetKubeCustomizationKubeProxyIptablesArgs'] = None,
                 ipvs: Optional['GetKubeCustomizationKubeProxyIpvsArgs'] = None):
        """
        :param 'GetKubeCustomizationKubeProxyIptablesArgs' iptables: Kubernetes cluster kube-proxy customization of iptables specific config.
        :param 'GetKubeCustomizationKubeProxyIpvsArgs' ipvs: Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        if iptables is not None:
            pulumi.set(__self__, "iptables", iptables)
        if ipvs is not None:
            pulumi.set(__self__, "ipvs", ipvs)

    @_builtins.property
    @pulumi.getter
    def iptables(self) -> Optional['GetKubeCustomizationKubeProxyIptablesArgs']:
        """
        Kubernetes cluster kube-proxy customization of iptables specific config.
        """
        return pulumi.get(self, "iptables")

    @iptables.setter
    def iptables(self, value: Optional['GetKubeCustomizationKubeProxyIptablesArgs']):
        pulumi.set(self, "iptables", value)

    @_builtins.property
    @pulumi.getter
    def ipvs(self) -> Optional['GetKubeCustomizationKubeProxyIpvsArgs']:
        """
        Kubernetes cluster kube-proxy customization of IPVS specific config (durations format is [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        return pulumi.get(self, "ipvs")

    @ipvs.setter
    def ipvs(self, value: Optional['GetKubeCustomizationKubeProxyIpvsArgs']):
        pulumi.set(self, "ipvs", value)


if not MYPY:
    class GetKubeCustomizationKubeProxyIptablesArgsDict(TypedDict):
        min_sync_period: NotRequired[_builtins.str]
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        sync_period: NotRequired[_builtins.str]
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        """
elif False:
    GetKubeCustomizationKubeProxyIptablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationKubeProxyIptablesArgs:
    def __init__(__self__, *,
                 min_sync_period: Optional[_builtins.str] = None,
                 sync_period: Optional[_builtins.str] = None):
        """
        :param _builtins.str min_sync_period: Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        :param _builtins.str sync_period: Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        """
        if min_sync_period is not None:
            pulumi.set(__self__, "min_sync_period", min_sync_period)
        if sync_period is not None:
            pulumi.set(__self__, "sync_period", sync_period)

    @_builtins.property
    @pulumi.getter(name="minSyncPeriod")
    def min_sync_period(self) -> Optional[_builtins.str]:
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        return pulumi.get(self, "min_sync_period")

    @min_sync_period.setter
    def min_sync_period(self, value: Optional[_builtins.str]):
        pulumi.set(self, "min_sync_period", value)

    @_builtins.property
    @pulumi.getter(name="syncPeriod")
    def sync_period(self) -> Optional[_builtins.str]:
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        """
        return pulumi.get(self, "sync_period")

    @sync_period.setter
    def sync_period(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sync_period", value)


if not MYPY:
    class GetKubeCustomizationKubeProxyIpvsArgsDict(TypedDict):
        min_sync_period: NotRequired[_builtins.str]
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        scheduler: NotRequired[_builtins.str]
        """
        IPVS scheduler.
        """
        sync_period: NotRequired[_builtins.str]
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        """
        tcp_fin_timeout: NotRequired[_builtins.str]
        """
        Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration.
        """
        tcp_timeout: NotRequired[_builtins.str]
        """
        Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        udp_timeout: NotRequired[_builtins.str]
        """
        timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
elif False:
    GetKubeCustomizationKubeProxyIpvsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeCustomizationKubeProxyIpvsArgs:
    def __init__(__self__, *,
                 min_sync_period: Optional[_builtins.str] = None,
                 scheduler: Optional[_builtins.str] = None,
                 sync_period: Optional[_builtins.str] = None,
                 tcp_fin_timeout: Optional[_builtins.str] = None,
                 tcp_timeout: Optional[_builtins.str] = None,
                 udp_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str min_sync_period: Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        :param _builtins.str scheduler: IPVS scheduler.
        :param _builtins.str sync_period: Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        :param _builtins.str tcp_fin_timeout: Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration.
        :param _builtins.str tcp_timeout: Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        :param _builtins.str udp_timeout: timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        if min_sync_period is not None:
            pulumi.set(__self__, "min_sync_period", min_sync_period)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)
        if sync_period is not None:
            pulumi.set(__self__, "sync_period", sync_period)
        if tcp_fin_timeout is not None:
            pulumi.set(__self__, "tcp_fin_timeout", tcp_fin_timeout)
        if tcp_timeout is not None:
            pulumi.set(__self__, "tcp_timeout", tcp_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="minSyncPeriod")
    def min_sync_period(self) -> Optional[_builtins.str]:
        """
        Minimum period that IPVS rules are refreshed in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        return pulumi.get(self, "min_sync_period")

    @min_sync_period.setter
    def min_sync_period(self, value: Optional[_builtins.str]):
        pulumi.set(self, "min_sync_period", value)

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional[_builtins.str]:
        """
        IPVS scheduler.
        """
        return pulumi.get(self, "scheduler")

    @scheduler.setter
    def scheduler(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scheduler", value)

    @_builtins.property
    @pulumi.getter(name="syncPeriod")
    def sync_period(self) -> Optional[_builtins.str]:
        """
        Minimum period that IPVS rules are refreshed, in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration format.
        """
        return pulumi.get(self, "sync_period")

    @sync_period.setter
    def sync_period(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sync_period", value)

    @_builtins.property
    @pulumi.getter(name="tcpFinTimeout")
    def tcp_fin_timeout(self) -> Optional[_builtins.str]:
        """
        Timeout value used for IPVS TCP sessions after receiving a FIN in RFC3339 duration.
        """
        return pulumi.get(self, "tcp_fin_timeout")

    @tcp_fin_timeout.setter
    def tcp_fin_timeout(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tcp_fin_timeout", value)

    @_builtins.property
    @pulumi.getter(name="tcpTimeout")
    def tcp_timeout(self) -> Optional[_builtins.str]:
        """
        Timeout value used for idle IPVS TCP sessions in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        return pulumi.get(self, "tcp_timeout")

    @tcp_timeout.setter
    def tcp_timeout(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tcp_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[_builtins.str]:
        """
        timeout value used for IPVS UDP packets in [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) duration.
        """
        return pulumi.get(self, "udp_timeout")

    @udp_timeout.setter
    def udp_timeout(self, value: Optional[_builtins.str]):
        pulumi.set(self, "udp_timeout", value)


if not MYPY:
    class GetKubeNodePoolTemplateArgsDict(TypedDict):
        metadata: NotRequired['GetKubeNodePoolTemplateMetadataArgsDict']
        """
        metadata
        """
        spec: NotRequired['GetKubeNodePoolTemplateSpecArgsDict']
        """
        spec
        """
elif False:
    GetKubeNodePoolTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeNodePoolTemplateArgs:
    def __init__(__self__, *,
                 metadata: Optional['GetKubeNodePoolTemplateMetadataArgs'] = None,
                 spec: Optional['GetKubeNodePoolTemplateSpecArgs'] = None):
        """
        :param 'GetKubeNodePoolTemplateMetadataArgs' metadata: metadata
        :param 'GetKubeNodePoolTemplateSpecArgs' spec: spec
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['GetKubeNodePoolTemplateMetadataArgs']:
        """
        metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional['GetKubeNodePoolTemplateMetadataArgs']):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['GetKubeNodePoolTemplateSpecArgs']:
        """
        spec
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional['GetKubeNodePoolTemplateSpecArgs']):
        pulumi.set(self, "spec", value)


if not MYPY:
    class GetKubeNodePoolTemplateMetadataArgsDict(TypedDict):
        annotations: NotRequired[Mapping[str, _builtins.str]]
        """
        annotations
        """
        finalizers: NotRequired[Sequence[_builtins.str]]
        """
        finalizers
        """
        labels: NotRequired[Mapping[str, _builtins.str]]
        """
        labels
        """
elif False:
    GetKubeNodePoolTemplateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeNodePoolTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 finalizers: Optional[Sequence[_builtins.str]] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] annotations: annotations
        :param Sequence[_builtins.str] finalizers: finalizers
        :param Mapping[str, _builtins.str] labels: labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if finalizers is not None:
            pulumi.set(__self__, "finalizers", finalizers)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def finalizers(self) -> Optional[Sequence[_builtins.str]]:
        """
        finalizers
        """
        return pulumi.get(self, "finalizers")

    @finalizers.setter
    def finalizers(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "finalizers", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class GetKubeNodePoolTemplateSpecArgsDict(TypedDict):
        taints: NotRequired[Sequence[Mapping[str, _builtins.str]]]
        """
        taints
        """
        unschedulable: NotRequired[_builtins.bool]
        """
        unschedulable
        """
elif False:
    GetKubeNodePoolTemplateSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubeNodePoolTemplateSpecArgs:
    def __init__(__self__, *,
                 taints: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 unschedulable: Optional[_builtins.bool] = None):
        """
        :param Sequence[Mapping[str, _builtins.str]] taints: taints
        :param _builtins.bool unschedulable: unschedulable
        """
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unschedulable is not None:
            pulumi.set(__self__, "unschedulable", unschedulable)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        taints
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[Sequence[Mapping[str, _builtins.str]]]):
        pulumi.set(self, "taints", value)

    @_builtins.property
    @pulumi.getter
    def unschedulable(self) -> Optional[_builtins.bool]:
        """
        unschedulable
        """
        return pulumi.get(self, "unschedulable")

    @unschedulable.setter
    def unschedulable(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "unschedulable", value)


