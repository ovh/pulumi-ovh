# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'PolicyConditionsArgs',
    'PolicyConditionsArgsDict',
    'PolicyConditionsConditionArgs',
    'PolicyConditionsConditionArgsDict',
    'PolicyConditionsConditionConditionArgs',
    'PolicyConditionsConditionConditionArgsDict',
]

MYPY = False

if not MYPY:
    class PolicyConditionsArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Operator to combine conditions. Valid values are `AND`, `OR`, `NOT`, or `MATCH`.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionArgsDict']]]]
        """
        List of condition blocks. Each condition supports:
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
elif False:
    PolicyConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyConditionsArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionArgs']]]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: Operator to combine conditions. Valid values are `AND`, `OR`, `NOT`, or `MATCH`.
        :param pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionArgs']]] conditions: List of condition blocks. Each condition supports:
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] values: Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
        pulumi.set(__self__, "operator", operator)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to combine conditions. Valid values are `AND`, `OR`, `NOT`, or `MATCH`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionArgs']]]]:
        """
        List of condition blocks. Each condition supports:
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PolicyConditionsConditionArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Operator for this condition (typically `MATCH`).
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionConditionArgsDict']]]]
        """
        A list of nested conditions. This is the recursive part.
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of key-value pairs to match. Keys can reference:
        * Resource tags: `resource.Tag(tag_name)` (e.g., `resource.Tag(environment)`)
        * Date/time: `date(timezone).WeekDay`, `date(timezone).WeekDay.In` (e.g., `date(Europe/Paris).WeekDay`)
        * Request attributes: `request.IP`

        **Note:** Conditions can be nested up to 3 levels deep. The `MATCH` operator is terminal and cannot have sub-conditions.
        """
elif False:
    PolicyConditionsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyConditionsConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionConditionArgs']]]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: Operator for this condition (typically `MATCH`).
        :param pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionConditionArgs']]] conditions: A list of nested conditions. This is the recursive part.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] values: Map of key-value pairs to match. Keys can reference:
               * Resource tags: `resource.Tag(tag_name)` (e.g., `resource.Tag(environment)`)
               * Date/time: `date(timezone).WeekDay`, `date(timezone).WeekDay.In` (e.g., `date(Europe/Paris).WeekDay`)
               * Request attributes: `request.IP`
               
               **Note:** Conditions can be nested up to 3 levels deep. The `MATCH` operator is terminal and cannot have sub-conditions.
        """
        pulumi.set(__self__, "operator", operator)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for this condition (typically `MATCH`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionConditionArgs']]]]:
        """
        A list of nested conditions. This is the recursive part.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyConditionsConditionConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of key-value pairs to match. Keys can reference:
        * Resource tags: `resource.Tag(tag_name)` (e.g., `resource.Tag(environment)`)
        * Date/time: `date(timezone).WeekDay`, `date(timezone).WeekDay.In` (e.g., `date(Europe/Paris).WeekDay`)
        * Request attributes: `request.IP`

        **Note:** Conditions can be nested up to 3 levels deep. The `MATCH` operator is terminal and cannot have sub-conditions.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PolicyConditionsConditionConditionArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Operator for this condition (MATCH, AND, OR, NOT)
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
elif False:
    PolicyConditionsConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyConditionsConditionConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: Operator for this condition (MATCH, AND, OR, NOT)
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] values: Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for this condition (MATCH, AND, OR, NOT)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value pairs to match (e.g., resource.Tag(name), date(Europe/Paris).WeekDay, request.IP)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


