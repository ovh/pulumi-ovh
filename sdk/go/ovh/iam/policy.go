// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iam

import (
	"context"
	"reflect"

	"errors"
	"github.com/ovh/pulumi-ovh/sdk/go/ovh/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates an IAM policy.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ovh/pulumi-ovh/sdk/go/ovh/Iam"
//	"github.com/ovh/pulumi-ovh/sdk/go/ovh/Me"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			account, err := Me.GetMe(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			myGroup, err := Me.NewIdentityGroup(ctx, "myGroup", &Me.IdentityGroupArgs{
//				Description: pulumi.String("my_group created in Terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = Iam.NewPolicy(ctx, "manager", &Iam.PolicyArgs{
//				Description: pulumi.String("Users are allowed to use the OVH manager"),
//				Identities: pulumi.StringArray{
//					myGroup.GroupURN,
//				},
//				Resources: pulumi.StringArray{
//					pulumi.String(account.AccountURN),
//				},
//				Allows: pulumi.StringArray{
//					pulumi.String("account:apiovh:me/get"),
//					pulumi.String("account:apiovh:me/supportLevel/get"),
//					pulumi.String("account:apiovh:me/certificates/get"),
//					pulumi.String("account:apiovh:me/tag/get"),
//					pulumi.String("account:apiovh:services/get"),
//					pulumi.String("account:apiovh:*"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Policy struct {
	pulumi.CustomResourceState

	// List of actions allowed on resources by identities
	Allows pulumi.StringArrayOutput `pulumi:"allows"`
	// Creation date of this group.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// List of actions that will always be denied even if also allowed by this policy or another one.
	Denies pulumi.StringArrayOutput `pulumi:"denies"`
	// Description of the policy
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
	Excepts pulumi.StringArrayOutput `pulumi:"excepts"`
	// List of identities affected by the policy
	Identities pulumi.StringArrayOutput `pulumi:"identities"`
	// Name of the policy, must be unique
	Name pulumi.StringOutput `pulumi:"name"`
	// Owner of the policy.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
	PermissionsGroups pulumi.StringArrayOutput `pulumi:"permissionsGroups"`
	// Indicates that the policy is a default one.
	ReadOnly pulumi.BoolOutput `pulumi:"readOnly"`
	// List of resources affected by the policy
	Resources pulumi.StringArrayOutput `pulumi:"resources"`
	// Date of the last update of this group.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewPolicy registers a new resource with the given unique name, arguments, and options.
func NewPolicy(ctx *pulumi.Context,
	name string, args *PolicyArgs, opts ...pulumi.ResourceOption) (*Policy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Identities == nil {
		return nil, errors.New("invalid value for required argument 'Identities'")
	}
	if args.Resources == nil {
		return nil, errors.New("invalid value for required argument 'Resources'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Policy
	err := ctx.RegisterResource("ovh:Iam/policy:Policy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicy gets an existing Policy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyState, opts ...pulumi.ResourceOption) (*Policy, error) {
	var resource Policy
	err := ctx.ReadResource("ovh:Iam/policy:Policy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Policy resources.
type policyState struct {
	// List of actions allowed on resources by identities
	Allows []string `pulumi:"allows"`
	// Creation date of this group.
	CreatedAt *string `pulumi:"createdAt"`
	// List of actions that will always be denied even if also allowed by this policy or another one.
	Denies []string `pulumi:"denies"`
	// Description of the policy
	Description *string `pulumi:"description"`
	// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
	Excepts []string `pulumi:"excepts"`
	// List of identities affected by the policy
	Identities []string `pulumi:"identities"`
	// Name of the policy, must be unique
	Name *string `pulumi:"name"`
	// Owner of the policy.
	Owner *string `pulumi:"owner"`
	// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
	PermissionsGroups []string `pulumi:"permissionsGroups"`
	// Indicates that the policy is a default one.
	ReadOnly *bool `pulumi:"readOnly"`
	// List of resources affected by the policy
	Resources []string `pulumi:"resources"`
	// Date of the last update of this group.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type PolicyState struct {
	// List of actions allowed on resources by identities
	Allows pulumi.StringArrayInput
	// Creation date of this group.
	CreatedAt pulumi.StringPtrInput
	// List of actions that will always be denied even if also allowed by this policy or another one.
	Denies pulumi.StringArrayInput
	// Description of the policy
	Description pulumi.StringPtrInput
	// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
	Excepts pulumi.StringArrayInput
	// List of identities affected by the policy
	Identities pulumi.StringArrayInput
	// Name of the policy, must be unique
	Name pulumi.StringPtrInput
	// Owner of the policy.
	Owner pulumi.StringPtrInput
	// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
	PermissionsGroups pulumi.StringArrayInput
	// Indicates that the policy is a default one.
	ReadOnly pulumi.BoolPtrInput
	// List of resources affected by the policy
	Resources pulumi.StringArrayInput
	// Date of the last update of this group.
	UpdatedAt pulumi.StringPtrInput
}

func (PolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyState)(nil)).Elem()
}

type policyArgs struct {
	// List of actions allowed on resources by identities
	Allows []string `pulumi:"allows"`
	// List of actions that will always be denied even if also allowed by this policy or another one.
	Denies []string `pulumi:"denies"`
	// Description of the policy
	Description *string `pulumi:"description"`
	// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
	Excepts []string `pulumi:"excepts"`
	// List of identities affected by the policy
	Identities []string `pulumi:"identities"`
	// Name of the policy, must be unique
	Name *string `pulumi:"name"`
	// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
	PermissionsGroups []string `pulumi:"permissionsGroups"`
	// List of resources affected by the policy
	Resources []string `pulumi:"resources"`
}

// The set of arguments for constructing a Policy resource.
type PolicyArgs struct {
	// List of actions allowed on resources by identities
	Allows pulumi.StringArrayInput
	// List of actions that will always be denied even if also allowed by this policy or another one.
	Denies pulumi.StringArrayInput
	// Description of the policy
	Description pulumi.StringPtrInput
	// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
	Excepts pulumi.StringArrayInput
	// List of identities affected by the policy
	Identities pulumi.StringArrayInput
	// Name of the policy, must be unique
	Name pulumi.StringPtrInput
	// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
	PermissionsGroups pulumi.StringArrayInput
	// List of resources affected by the policy
	Resources pulumi.StringArrayInput
}

func (PolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyArgs)(nil)).Elem()
}

type PolicyInput interface {
	pulumi.Input

	ToPolicyOutput() PolicyOutput
	ToPolicyOutputWithContext(ctx context.Context) PolicyOutput
}

func (*Policy) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (i *Policy) ToPolicyOutput() PolicyOutput {
	return i.ToPolicyOutputWithContext(context.Background())
}

func (i *Policy) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyOutput)
}

// PolicyArrayInput is an input type that accepts PolicyArray and PolicyArrayOutput values.
// You can construct a concrete instance of `PolicyArrayInput` via:
//
//	PolicyArray{ PolicyArgs{...} }
type PolicyArrayInput interface {
	pulumi.Input

	ToPolicyArrayOutput() PolicyArrayOutput
	ToPolicyArrayOutputWithContext(context.Context) PolicyArrayOutput
}

type PolicyArray []PolicyInput

func (PolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (i PolicyArray) ToPolicyArrayOutput() PolicyArrayOutput {
	return i.ToPolicyArrayOutputWithContext(context.Background())
}

func (i PolicyArray) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyArrayOutput)
}

// PolicyMapInput is an input type that accepts PolicyMap and PolicyMapOutput values.
// You can construct a concrete instance of `PolicyMapInput` via:
//
//	PolicyMap{ "key": PolicyArgs{...} }
type PolicyMapInput interface {
	pulumi.Input

	ToPolicyMapOutput() PolicyMapOutput
	ToPolicyMapOutputWithContext(context.Context) PolicyMapOutput
}

type PolicyMap map[string]PolicyInput

func (PolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (i PolicyMap) ToPolicyMapOutput() PolicyMapOutput {
	return i.ToPolicyMapOutputWithContext(context.Background())
}

func (i PolicyMap) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapOutput)
}

type PolicyOutput struct{ *pulumi.OutputState }

func (PolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (o PolicyOutput) ToPolicyOutput() PolicyOutput {
	return o
}

func (o PolicyOutput) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return o
}

// List of actions allowed on resources by identities
func (o PolicyOutput) Allows() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.Allows }).(pulumi.StringArrayOutput)
}

// Creation date of this group.
func (o PolicyOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// List of actions that will always be denied even if also allowed by this policy or another one.
func (o PolicyOutput) Denies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.Denies }).(pulumi.StringArrayOutput)
}

// Description of the policy
func (o PolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// List of overrides of action that must not be allowed even if they are caught by allow. Only makes sens if allow contains wildcards.
func (o PolicyOutput) Excepts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.Excepts }).(pulumi.StringArrayOutput)
}

// List of identities affected by the policy
func (o PolicyOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.Identities }).(pulumi.StringArrayOutput)
}

// Name of the policy, must be unique
func (o PolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Owner of the policy.
func (o PolicyOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// Set of permissions groups included in the policy. At evaluation, these permissions groups are each evaluated independently (notably, excepts actions only affect actions in the same permission group).
func (o PolicyOutput) PermissionsGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.PermissionsGroups }).(pulumi.StringArrayOutput)
}

// Indicates that the policy is a default one.
func (o PolicyOutput) ReadOnly() pulumi.BoolOutput {
	return o.ApplyT(func(v *Policy) pulumi.BoolOutput { return v.ReadOnly }).(pulumi.BoolOutput)
}

// List of resources affected by the policy
func (o PolicyOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringArrayOutput { return v.Resources }).(pulumi.StringArrayOutput)
}

// Date of the last update of this group.
func (o PolicyOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type PolicyArrayOutput struct{ *pulumi.OutputState }

func (PolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (o PolicyArrayOutput) ToPolicyArrayOutput() PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) Index(i pulumi.IntInput) PolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].([]*Policy)[vs[1].(int)]
	}).(PolicyOutput)
}

type PolicyMapOutput struct{ *pulumi.OutputState }

func (PolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (o PolicyMapOutput) ToPolicyMapOutput() PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) MapIndex(k pulumi.StringInput) PolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].(map[string]*Policy)[vs[1].(string)]
	}).(PolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInput)(nil)).Elem(), &Policy{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyArrayInput)(nil)).Elem(), PolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapInput)(nil)).Elem(), PolicyMap{})
	pulumi.RegisterOutputType(PolicyOutput{})
	pulumi.RegisterOutputType(PolicyArrayOutput{})
	pulumi.RegisterOutputType(PolicyMapOutput{})
}
