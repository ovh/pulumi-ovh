// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vrack

import (
	"context"
	"reflect"

	"errors"
	"github.com/ovh/pulumi-ovh/sdk/v2/go/ovh/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Attach a Dedicated Cloud to the vrack.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ovh/pulumi-ovh/sdk/v2/go/ovh/vrack"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vrack.NewDedicatedCloud(ctx, "vrack-dedicatedCloud", &vrack.DedicatedCloudArgs{
//				DedicatedCloud: pulumi.String("<Dedicated Cloud service name>"),
//				ServiceName:    pulumi.String("<vRack service name>"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Attachment of a Dedicated Cloud and a vRack can be imported using the `service_name` (vRack identifier) and the `dedicated_cloud` (Dedicated Cloud service name), separated by "/" E.g.,
//
// bash
//
// ```sh
// $ pulumi import ovh:Vrack/dedicatedCloud:DedicatedCloud myattach "<vRack service name>/<Dedicated Cloud service name>"
// ```
type DedicatedCloud struct {
	pulumi.CustomResourceState

	// Your Dedicated Cloud service name
	DedicatedCloud pulumi.StringOutput `pulumi:"dedicatedCloud"`
	// The internal name of your vrack
	ServiceName pulumi.StringOutput `pulumi:"serviceName"`
}

// NewDedicatedCloud registers a new resource with the given unique name, arguments, and options.
func NewDedicatedCloud(ctx *pulumi.Context,
	name string, args *DedicatedCloudArgs, opts ...pulumi.ResourceOption) (*DedicatedCloud, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DedicatedCloud == nil {
		return nil, errors.New("invalid value for required argument 'DedicatedCloud'")
	}
	if args.ServiceName == nil {
		return nil, errors.New("invalid value for required argument 'ServiceName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DedicatedCloud
	err := ctx.RegisterResource("ovh:Vrack/dedicatedCloud:DedicatedCloud", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDedicatedCloud gets an existing DedicatedCloud resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDedicatedCloud(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DedicatedCloudState, opts ...pulumi.ResourceOption) (*DedicatedCloud, error) {
	var resource DedicatedCloud
	err := ctx.ReadResource("ovh:Vrack/dedicatedCloud:DedicatedCloud", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DedicatedCloud resources.
type dedicatedCloudState struct {
	// Your Dedicated Cloud service name
	DedicatedCloud *string `pulumi:"dedicatedCloud"`
	// The internal name of your vrack
	ServiceName *string `pulumi:"serviceName"`
}

type DedicatedCloudState struct {
	// Your Dedicated Cloud service name
	DedicatedCloud pulumi.StringPtrInput
	// The internal name of your vrack
	ServiceName pulumi.StringPtrInput
}

func (DedicatedCloudState) ElementType() reflect.Type {
	return reflect.TypeOf((*dedicatedCloudState)(nil)).Elem()
}

type dedicatedCloudArgs struct {
	// Your Dedicated Cloud service name
	DedicatedCloud string `pulumi:"dedicatedCloud"`
	// The internal name of your vrack
	ServiceName string `pulumi:"serviceName"`
}

// The set of arguments for constructing a DedicatedCloud resource.
type DedicatedCloudArgs struct {
	// Your Dedicated Cloud service name
	DedicatedCloud pulumi.StringInput
	// The internal name of your vrack
	ServiceName pulumi.StringInput
}

func (DedicatedCloudArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dedicatedCloudArgs)(nil)).Elem()
}

type DedicatedCloudInput interface {
	pulumi.Input

	ToDedicatedCloudOutput() DedicatedCloudOutput
	ToDedicatedCloudOutputWithContext(ctx context.Context) DedicatedCloudOutput
}

func (*DedicatedCloud) ElementType() reflect.Type {
	return reflect.TypeOf((**DedicatedCloud)(nil)).Elem()
}

func (i *DedicatedCloud) ToDedicatedCloudOutput() DedicatedCloudOutput {
	return i.ToDedicatedCloudOutputWithContext(context.Background())
}

func (i *DedicatedCloud) ToDedicatedCloudOutputWithContext(ctx context.Context) DedicatedCloudOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DedicatedCloudOutput)
}

// DedicatedCloudArrayInput is an input type that accepts DedicatedCloudArray and DedicatedCloudArrayOutput values.
// You can construct a concrete instance of `DedicatedCloudArrayInput` via:
//
//	DedicatedCloudArray{ DedicatedCloudArgs{...} }
type DedicatedCloudArrayInput interface {
	pulumi.Input

	ToDedicatedCloudArrayOutput() DedicatedCloudArrayOutput
	ToDedicatedCloudArrayOutputWithContext(context.Context) DedicatedCloudArrayOutput
}

type DedicatedCloudArray []DedicatedCloudInput

func (DedicatedCloudArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DedicatedCloud)(nil)).Elem()
}

func (i DedicatedCloudArray) ToDedicatedCloudArrayOutput() DedicatedCloudArrayOutput {
	return i.ToDedicatedCloudArrayOutputWithContext(context.Background())
}

func (i DedicatedCloudArray) ToDedicatedCloudArrayOutputWithContext(ctx context.Context) DedicatedCloudArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DedicatedCloudArrayOutput)
}

// DedicatedCloudMapInput is an input type that accepts DedicatedCloudMap and DedicatedCloudMapOutput values.
// You can construct a concrete instance of `DedicatedCloudMapInput` via:
//
//	DedicatedCloudMap{ "key": DedicatedCloudArgs{...} }
type DedicatedCloudMapInput interface {
	pulumi.Input

	ToDedicatedCloudMapOutput() DedicatedCloudMapOutput
	ToDedicatedCloudMapOutputWithContext(context.Context) DedicatedCloudMapOutput
}

type DedicatedCloudMap map[string]DedicatedCloudInput

func (DedicatedCloudMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DedicatedCloud)(nil)).Elem()
}

func (i DedicatedCloudMap) ToDedicatedCloudMapOutput() DedicatedCloudMapOutput {
	return i.ToDedicatedCloudMapOutputWithContext(context.Background())
}

func (i DedicatedCloudMap) ToDedicatedCloudMapOutputWithContext(ctx context.Context) DedicatedCloudMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DedicatedCloudMapOutput)
}

type DedicatedCloudOutput struct{ *pulumi.OutputState }

func (DedicatedCloudOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DedicatedCloud)(nil)).Elem()
}

func (o DedicatedCloudOutput) ToDedicatedCloudOutput() DedicatedCloudOutput {
	return o
}

func (o DedicatedCloudOutput) ToDedicatedCloudOutputWithContext(ctx context.Context) DedicatedCloudOutput {
	return o
}

// Your Dedicated Cloud service name
func (o DedicatedCloudOutput) DedicatedCloud() pulumi.StringOutput {
	return o.ApplyT(func(v *DedicatedCloud) pulumi.StringOutput { return v.DedicatedCloud }).(pulumi.StringOutput)
}

// The internal name of your vrack
func (o DedicatedCloudOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v *DedicatedCloud) pulumi.StringOutput { return v.ServiceName }).(pulumi.StringOutput)
}

type DedicatedCloudArrayOutput struct{ *pulumi.OutputState }

func (DedicatedCloudArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DedicatedCloud)(nil)).Elem()
}

func (o DedicatedCloudArrayOutput) ToDedicatedCloudArrayOutput() DedicatedCloudArrayOutput {
	return o
}

func (o DedicatedCloudArrayOutput) ToDedicatedCloudArrayOutputWithContext(ctx context.Context) DedicatedCloudArrayOutput {
	return o
}

func (o DedicatedCloudArrayOutput) Index(i pulumi.IntInput) DedicatedCloudOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DedicatedCloud {
		return vs[0].([]*DedicatedCloud)[vs[1].(int)]
	}).(DedicatedCloudOutput)
}

type DedicatedCloudMapOutput struct{ *pulumi.OutputState }

func (DedicatedCloudMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DedicatedCloud)(nil)).Elem()
}

func (o DedicatedCloudMapOutput) ToDedicatedCloudMapOutput() DedicatedCloudMapOutput {
	return o
}

func (o DedicatedCloudMapOutput) ToDedicatedCloudMapOutputWithContext(ctx context.Context) DedicatedCloudMapOutput {
	return o
}

func (o DedicatedCloudMapOutput) MapIndex(k pulumi.StringInput) DedicatedCloudOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DedicatedCloud {
		return vs[0].(map[string]*DedicatedCloud)[vs[1].(string)]
	}).(DedicatedCloudOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DedicatedCloudInput)(nil)).Elem(), &DedicatedCloud{})
	pulumi.RegisterInputType(reflect.TypeOf((*DedicatedCloudArrayInput)(nil)).Elem(), DedicatedCloudArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DedicatedCloudMapInput)(nil)).Elem(), DedicatedCloudMap{})
	pulumi.RegisterOutputType(DedicatedCloudOutput{})
	pulumi.RegisterOutputType(DedicatedCloudArrayOutput{})
	pulumi.RegisterOutputType(DedicatedCloudMapOutput{})
}
